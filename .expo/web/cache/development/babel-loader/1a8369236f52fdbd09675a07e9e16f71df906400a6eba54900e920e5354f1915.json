{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.linkTo = exports.setParams = exports.canDismiss = exports.canGoBack = exports.goBack = exports.dismissAll = exports.replace = exports.dismissTo = exports.dismiss = exports.push = exports.reload = exports.navigate = void 0;\nvar native_1 = require(\"@react-navigation/native\");\nvar dom_1 = require(\"expo/dom\");\nvar Linking = __importStar(require(\"expo-linking\"));\nvar non_secure_1 = require(\"nanoid/non-secure\");\nvar react_native_1 = require(\"react-native-web/dist/index\");\nvar href_1 = require(\"../link/href\");\nvar useDomComponentNavigation_1 = require(\"../link/useDomComponentNavigation\");\nvar matchers_1 = require(\"../matchers\");\nvar url_1 = require(\"../utils/url\");\nfunction assertIsReady(store) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error('Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.');\n  }\n}\nfunction navigate(url, options) {\n  return this.linkTo((0, href_1.resolveHref)(url), _objectSpread(_objectSpread({}, options), {}, {\n    event: 'NAVIGATE'\n  }));\n}\nexports.navigate = navigate;\nfunction reload() {\n  throw new Error('The reload method is not implemented in the client-side router yet.');\n}\nexports.reload = reload;\nfunction push(url, options) {\n  return this.linkTo((0, href_1.resolveHref)(url), _objectSpread(_objectSpread({}, options), {}, {\n    event: 'PUSH'\n  }));\n}\nexports.push = push;\nfunction dismiss(count) {\n  var _this$navigationRef;\n  if ((0, useDomComponentNavigation_1.emitDomDismiss)(count)) {\n    return;\n  }\n  (_this$navigationRef = this.navigationRef) == null ? void 0 : _this$navigationRef.dispatch(native_1.StackActions.pop(count));\n}\nexports.dismiss = dismiss;\nfunction dismissTo(href, options) {\n  return this.linkTo((0, href_1.resolveHref)(href), _objectSpread(_objectSpread({}, options), {}, {\n    event: 'POP_TO'\n  }));\n}\nexports.dismissTo = dismissTo;\nfunction replace(url, options) {\n  return this.linkTo((0, href_1.resolveHref)(url), _objectSpread(_objectSpread({}, options), {}, {\n    event: 'REPLACE'\n  }));\n}\nexports.replace = replace;\nfunction dismissAll() {\n  var _this$navigationRef2;\n  if ((0, useDomComponentNavigation_1.emitDomDismissAll)()) {\n    return;\n  }\n  (_this$navigationRef2 = this.navigationRef) == null ? void 0 : _this$navigationRef2.dispatch(native_1.StackActions.popToTop());\n}\nexports.dismissAll = dismissAll;\nfunction goBack() {\n  var _this$navigationRef3, _this$navigationRef3$;\n  if ((0, useDomComponentNavigation_1.emitDomGoBack)()) {\n    return;\n  }\n  assertIsReady(this);\n  (_this$navigationRef3 = this.navigationRef) == null ? void 0 : (_this$navigationRef3$ = _this$navigationRef3.current) == null ? void 0 : _this$navigationRef3$.goBack();\n}\nexports.goBack = goBack;\nfunction canGoBack() {\n  var _this$navigationRef$c, _this$navigationRef4, _this$navigationRef4$;\n  if (dom_1.IS_DOM) {\n    throw new Error('canGoBack imperative method is not supported. Pass the property to the DOM component instead.');\n  }\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return (_this$navigationRef$c = (_this$navigationRef4 = this.navigationRef) == null ? void 0 : (_this$navigationRef4$ = _this$navigationRef4.current) == null ? void 0 : _this$navigationRef4$.canGoBack()) != null ? _this$navigationRef$c : false;\n}\nexports.canGoBack = canGoBack;\nfunction canDismiss() {\n  if (dom_1.IS_DOM) {\n    throw new Error('canDismiss imperative method is not supported. Pass the property to the DOM component instead.');\n  }\n  var state = this.rootState;\n  while (state) {\n    var _state$routes, _state$routes$state$i;\n    if (state.type === 'stack' && state.routes.length > 1) {\n      return true;\n    }\n    if (state.index === undefined) return false;\n    state = (_state$routes = state.routes) == null ? void 0 : (_state$routes$state$i = _state$routes[state.index]) == null ? void 0 : _state$routes$state$i.state;\n  }\n  return false;\n}\nexports.canDismiss = canDismiss;\nfunction setParams() {\n  var _this$navigationRef5, _this$navigationRef5$;\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if ((0, useDomComponentNavigation_1.emitDomSetParams)(params)) {\n    return;\n  }\n  assertIsReady(this);\n  return ((_this$navigationRef5 = this.navigationRef) == null ? void 0 : (_this$navigationRef5$ = _this$navigationRef5.current) == null ? void 0 : _this$navigationRef5$.setParams.bind(_this$navigationRef5$))(params);\n}\nexports.setParams = setParams;\nfunction linkTo(href) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    event = _ref.event,\n    relativeToDirectory = _ref.relativeToDirectory,\n    withAnchor = _ref.withAnchor;\n  if ((0, useDomComponentNavigation_1.emitDomLinkEvent)(href, {\n    event: event,\n    relativeToDirectory: relativeToDirectory,\n    withAnchor: withAnchor\n  })) {\n    return;\n  }\n  if ((0, url_1.shouldLinkExternally)(href)) {\n    if (href.startsWith('//') && react_native_1.Platform.OS !== 'web') {\n      href = `https:${href}`;\n    }\n    Linking.openURL(href);\n    return;\n  }\n  assertIsReady(this);\n  var navigationRef = this.navigationRef.current;\n  if (navigationRef == null) {\n    throw new Error(\"Couldn't find a navigation object. Is your component inside NavigationContainer?\");\n  }\n  if (!this.linking) {\n    throw new Error('Attempted to link to route when no routes are present');\n  }\n  if (href === '..' || href === '../') {\n    navigationRef.goBack();\n    return;\n  }\n  var rootState = navigationRef.getRootState();\n  href = (0, href_1.resolveHrefStringWithSegments)(href, this.routeInfo, relativeToDirectory);\n  var state = this.linking.getStateFromPath(href, this.linking.config);\n  if (!state || state.routes.length === 0) {\n    console.error('Could not generate a valid navigation state for the given path: ' + href);\n    return;\n  }\n  return navigationRef.dispatch(getNavigateAction(state, rootState, event, withAnchor));\n}\nexports.linkTo = linkTo;\nfunction getNavigateAction(actionState, navigationState) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'NAVIGATE';\n  var withAnchor = arguments.length > 3 ? arguments[3] : undefined;\n  var actionStateRoute;\n  while (actionState && navigationState) {\n    var _actionStateRoute$par, _stateRoute$params;\n    var stateRoute = navigationState.routes[navigationState.index];\n    actionStateRoute = actionState.routes[actionState.routes.length - 1];\n    var childState = actionStateRoute.state;\n    var nextNavigationState = stateRoute.state;\n    var dynamicName = (0, matchers_1.matchDynamicName)(actionStateRoute.name);\n    var didActionAndCurrentStateDiverge = actionStateRoute.name !== stateRoute.name || !childState || !nextNavigationState || dynamicName && ((_actionStateRoute$par = actionStateRoute.params) == null ? void 0 : _actionStateRoute$par[dynamicName]) !== ((_stateRoute$params = stateRoute.params) == null ? void 0 : _stateRoute$params[dynamicName]);\n    if (didActionAndCurrentStateDiverge) {\n      break;\n    }\n    actionState = childState;\n    navigationState = nextNavigationState;\n  }\n  var rootPayload = {\n    params: {}\n  };\n  var payload = rootPayload;\n  var params = payload.params;\n  while (actionStateRoute) {\n    var _actionStateRoute$sta, _actionStateRoute$sta2;\n    Object.assign(params, _objectSpread(_objectSpread({}, payload.params), actionStateRoute.params));\n    payload.screen = actionStateRoute.name;\n    payload.params = _objectSpread({}, params);\n    delete payload.params['screen'];\n    payload = payload.params;\n    params = payload;\n    actionStateRoute = (_actionStateRoute$sta = actionStateRoute.state) == null ? void 0 : _actionStateRoute$sta.routes[((_actionStateRoute$sta2 = actionStateRoute.state) == null ? void 0 : _actionStateRoute$sta2.routes.length) - 1];\n  }\n  if (type === 'PUSH') {\n    type = 'NAVIGATE';\n    if (navigationState.type === 'stack') {\n      rootPayload.params.__EXPO_ROUTER_key = `${rootPayload.name}-${(0, non_secure_1.nanoid)()}`;\n    }\n  }\n  if (navigationState.type === 'expo-tab') {\n    type = 'JUMP_TO';\n  }\n  if (type === 'REPLACE' && (navigationState.type === 'tab' || navigationState.type === 'drawer')) {\n    type = 'JUMP_TO';\n  }\n  if (withAnchor !== undefined) {\n    if (rootPayload.params.initial) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(`The parameter 'initial' is a reserved parameter name in React Navigation`);\n      }\n    }\n    rootPayload.params.initial = !withAnchor;\n  }\n  return {\n    type: type,\n    target: navigationState.key,\n    payload: {\n      name: rootPayload.screen,\n      params: rootPayload.params\n    }\n  };\n}","map":{"version":3,"names":["native_1","require","dom_1","Linking","__importStar","non_secure_1","react_native_1","href_1","useDomComponentNavigation_1","matchers_1","url_1","assertIsReady","store","navigationRef","isReady","Error","navigate","url","options","linkTo","resolveHref","_objectSpread","event","exports","reload","push","dismiss","count","_this$navigationRef","emitDomDismiss","dispatch","StackActions","pop","dismissTo","href","replace","dismissAll","_this$navigationRef2","emitDomDismissAll","popToTop","goBack","_this$navigationRef3","_this$navigationRef3$","emitDomGoBack","current","canGoBack","_this$navigationRef$c","_this$navigationRef4","_this$navigationRef4$","IS_DOM","canDismiss","state","rootState","_state$routes","_state$routes$state$i","type","routes","length","index","undefined","setParams","_this$navigationRef5","_this$navigationRef5$","params","arguments","emitDomSetParams","bind","_ref","relativeToDirectory","withAnchor","emitDomLinkEvent","shouldLinkExternally","startsWith","Platform","OS","openURL","linking","getRootState","resolveHrefStringWithSegments","routeInfo","getStateFromPath","config","console","error","getNavigateAction","actionState","navigationState","actionStateRoute","_actionStateRoute$par","_stateRoute$params","stateRoute","childState","nextNavigationState","dynamicName","matchDynamicName","name","didActionAndCurrentStateDiverge","rootPayload","payload","_actionStateRoute$sta","_actionStateRoute$sta2","Object","assign","screen","__EXPO_ROUTER_key","nanoid","initial","process","env","NODE_ENV","warn","target","key"],"sources":["C:\\Users\\R User\\Documents\\software_dev\\BranchBuddy\\node_modules\\expo-router\\src\\global-state\\routing.ts"],"sourcesContent":["import { StackActions, type NavigationState, PartialRoute } from '@react-navigation/native';\nimport { IS_DOM } from 'expo/dom';\nimport * as Linking from 'expo-linking';\nimport { nanoid } from 'nanoid/non-secure';\nimport { Platform } from 'react-native';\n\nimport { type RouterStore } from './router-store';\nimport { ResultState } from '../fork/getStateFromPath';\nimport { resolveHref, resolveHrefStringWithSegments } from '../link/href';\nimport {\n  emitDomDismiss,\n  emitDomDismissAll,\n  emitDomGoBack,\n  emitDomLinkEvent,\n  emitDomSetParams,\n} from '../link/useDomComponentNavigation';\nimport { matchDynamicName } from '../matchers';\nimport { Href } from '../types';\nimport { shouldLinkExternally } from '../utils/url';\n\nfunction assertIsReady(store: RouterStore) {\n  if (!store.navigationRef.isReady()) {\n    throw new Error(\n      'Attempted to navigate before mounting the Root Layout component. Ensure the Root Layout component is rendering a Slot, or other navigator on the first render.'\n    );\n  }\n}\n\nexport type NavigationOptions = Omit<LinkToOptions, 'event'>;\n\nexport function navigate(this: RouterStore, url: Href, options?: NavigationOptions) {\n  return this.linkTo(resolveHref(url), { ...options, event: 'NAVIGATE' });\n}\n\nexport function reload(this: RouterStore) {\n  // TODO(EvanBacon): add `reload` support.\n  throw new Error('The reload method is not implemented in the client-side router yet.');\n}\n\nexport function push(this: RouterStore, url: Href, options?: NavigationOptions) {\n  return this.linkTo(resolveHref(url), { ...options, event: 'PUSH' });\n}\n\nexport function dismiss(this: RouterStore, count?: number) {\n  if (emitDomDismiss(count)) {\n    return;\n  }\n  this.navigationRef?.dispatch(StackActions.pop(count));\n}\n\nexport function dismissTo(this: RouterStore, href: Href, options?: NavigationOptions) {\n  return this.linkTo(resolveHref(href), { ...options, event: 'POP_TO' });\n}\n\nexport function replace(this: RouterStore, url: Href, options?: NavigationOptions) {\n  return this.linkTo(resolveHref(url), { ...options, event: 'REPLACE' });\n}\n\nexport function dismissAll(this: RouterStore) {\n  if (emitDomDismissAll()) {\n    return;\n  }\n  this.navigationRef?.dispatch(StackActions.popToTop());\n}\n\nexport function goBack(this: RouterStore) {\n  if (emitDomGoBack()) {\n    return;\n  }\n  assertIsReady(this);\n  this.navigationRef?.current?.goBack();\n}\n\nexport function canGoBack(this: RouterStore): boolean {\n  if (IS_DOM) {\n    throw new Error(\n      'canGoBack imperative method is not supported. Pass the property to the DOM component instead.'\n    );\n  }\n  // Return a default value here if the navigation hasn't mounted yet.\n  // This can happen if the user calls `canGoBack` from the Root Layout route\n  // before mounting a navigator. This behavior exists due to React Navigation being dynamically\n  // constructed at runtime. We can get rid of this in the future if we use\n  // the static configuration internally.\n  if (!this.navigationRef.isReady()) {\n    return false;\n  }\n  return this.navigationRef?.current?.canGoBack() ?? false;\n}\n\nexport function canDismiss(this: RouterStore): boolean {\n  if (IS_DOM) {\n    throw new Error(\n      'canDismiss imperative method is not supported. Pass the property to the DOM component instead.'\n    );\n  }\n  let state = this.rootState;\n\n  // Keep traversing down the state tree until we find a stack navigator that we can pop\n  while (state) {\n    if (state.type === 'stack' && state.routes.length > 1) {\n      return true;\n    }\n    if (state.index === undefined) return false;\n\n    state = state.routes?.[state.index]?.state as any;\n  }\n\n  return false;\n}\n\nexport function setParams(\n  this: RouterStore,\n  params: Record<string, string | number | (string | number)[]> = {}\n) {\n  if (emitDomSetParams(params)) {\n    return;\n  }\n  assertIsReady(this);\n  return (this.navigationRef?.current?.setParams as any)(params);\n}\n\nexport type LinkToOptions = {\n  event?: string;\n\n  /**\n   * Relative URL references are either relative to the directory or the document. By default, relative paths are relative to the document.\n   * @see: [MDN's documentation on Resolving relative references to a URL](https://developer.mozilla.org/en-US/docs/Web/API/URL_API/Resolving_relative_references).\n   */\n  relativeToDirectory?: boolean;\n\n  /**\n   *\n   */\n  withAnchor?: boolean;\n};\n\nexport function linkTo(\n  this: RouterStore,\n  href: string,\n  { event, relativeToDirectory, withAnchor }: LinkToOptions = {}\n) {\n  if (emitDomLinkEvent(href, { event, relativeToDirectory, withAnchor })) {\n    return;\n  }\n\n  if (shouldLinkExternally(href)) {\n    if (href.startsWith('//') && Platform.OS !== 'web') {\n      href = `https:${href}`;\n    }\n\n    Linking.openURL(href);\n    return;\n  }\n\n  assertIsReady(this);\n  const navigationRef = this.navigationRef.current;\n\n  if (navigationRef == null) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  if (!this.linking) {\n    throw new Error('Attempted to link to route when no routes are present');\n  }\n\n  if (href === '..' || href === '../') {\n    navigationRef.goBack();\n    return;\n  }\n\n  const rootState = navigationRef.getRootState();\n\n  href = resolveHrefStringWithSegments(href, this.routeInfo, relativeToDirectory);\n\n  const state = this.linking.getStateFromPath!(href, this.linking.config);\n\n  if (!state || state.routes.length === 0) {\n    console.error('Could not generate a valid navigation state for the given path: ' + href);\n    return;\n  }\n\n  return navigationRef.dispatch(getNavigateAction(state, rootState, event, withAnchor));\n}\n\nfunction getNavigateAction(\n  actionState: ResultState,\n  navigationState: NavigationState,\n  type = 'NAVIGATE',\n  withAnchor?: boolean\n) {\n  /**\n   * We need to find the deepest navigator where the action and current state diverge, If they do not diverge, the\n   * lowest navigator is the target.\n   *\n   * By default React Navigation will target the current navigator, but this doesn't work for all actions\n   * For example:\n   *  - /deeply/nested/route -> /top-level-route the target needs to be the top-level navigator\n   *  - /stack/nestedStack/page -> /stack1/nestedStack/other-page needs to target the nestedStack navigator\n   *\n   * This matching needs to done by comparing the route names and the dynamic path, for example\n   * - /1/page -> /2/anotherPage needs to target the /[id] navigator\n   *\n   * Other parameters such as search params and hash are not evaluated.\n   */\n  let actionStateRoute: PartialRoute<any> | undefined;\n\n  // Traverse the state tree comparing the current state and the action state until we find where they diverge\n  while (actionState && navigationState) {\n    const stateRoute = navigationState.routes[navigationState.index];\n\n    actionStateRoute = actionState.routes[actionState.routes.length - 1];\n\n    const childState = actionStateRoute.state;\n    const nextNavigationState = stateRoute.state;\n\n    const dynamicName = matchDynamicName(actionStateRoute.name);\n\n    const didActionAndCurrentStateDiverge =\n      actionStateRoute.name !== stateRoute.name ||\n      !childState ||\n      !nextNavigationState ||\n      (dynamicName && actionStateRoute.params?.[dynamicName] !== stateRoute.params?.[dynamicName]);\n\n    if (didActionAndCurrentStateDiverge) {\n      break;\n    }\n\n    actionState = childState;\n    navigationState = nextNavigationState as NavigationState;\n  }\n\n  /*\n   * We found the target navigator, but the payload is in the incorrect format\n   * We need to convert the action state to a payload that can be dispatched\n   */\n  const rootPayload: Record<string, any> = { params: {} };\n  let payload = rootPayload;\n  let params = payload.params;\n\n  // The root level of payload is a bit weird, its params are in the child object\n  while (actionStateRoute) {\n    Object.assign(params, { ...payload.params, ...actionStateRoute.params });\n    // Assign the screen name to the payload\n    payload.screen = actionStateRoute.name;\n    // Merge the params, ensuring that we create a new object\n    payload.params = { ...params };\n    // Params don't include the screen, thats a separate attribute\n    delete payload.params['screen'];\n\n    // Continue down the payload tree\n    // Initially these values are separate, but React Nav merges them after the first layer\n    payload = payload.params;\n    params = payload;\n\n    actionStateRoute = actionStateRoute.state?.routes[actionStateRoute.state?.routes.length - 1];\n  }\n\n  // Expo Router uses only three actions, but these don't directly translate to all navigator actions\n  if (type === 'PUSH') {\n    // Only stack navigators have a push action, and even then we want to use NAVIGATE (see below)\n    type = 'NAVIGATE';\n\n    /*\n     * The StackAction.PUSH does not work correctly with Expo Router.\n     *\n     * Expo Router provides a getId() function for every route, altering how React Navigation handles stack routing.\n     * Ordinarily, PUSH always adds a new screen to the stack. However, with getId() present, it navigates to the screen with the matching ID instead (by moving the screen to the top of the stack)\n     * When you try and push to a screen with the same ID, no navigation will occur\n     * Refer to: https://github.com/react-navigation/react-navigation/blob/13d4aa270b301faf07960b4cd861ffc91e9b2c46/packages/routers/src/StackRouter.tsx#L279-L290\n     *\n     * Expo Router needs to retain the default behavior of PUSH, consistently adding new screens to the stack, even if their IDs are identical.\n     *\n     * To resolve this issue, we switch to using a NAVIGATE action with a new key. In the navigate action, screens are matched by either key or getId() function.\n     * By generating a unique new key, we ensure that the screen is always pushed onto the stack.\n     *\n     */\n    if (navigationState.type === 'stack') {\n      rootPayload.params.__EXPO_ROUTER_key = `${rootPayload.name}-${nanoid()}`; // @see https://github.com/react-navigation/react-navigation/blob/13d4aa270b301faf07960b4cd861ffc91e9b2c46/packages/routers/src/StackRouter.tsx#L406-L407\n    }\n  }\n\n  if (navigationState.type === 'expo-tab') {\n    type = 'JUMP_TO';\n  }\n\n  if (type === 'REPLACE' && (navigationState.type === 'tab' || navigationState.type === 'drawer')) {\n    type = 'JUMP_TO';\n  }\n\n  if (withAnchor !== undefined) {\n    if (rootPayload.params.initial) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(`The parameter 'initial' is a reserved parameter name in React Navigation`);\n      }\n    }\n    /*\n     * The logic for initial can seen backwards depending on your perspective\n     *   True: The initialRouteName is not loaded. The incoming screen is the initial screen (default)\n     *   False: The initialRouteName is loaded. THe incoming screen is placed after the initialRouteName\n     *\n     * withAnchor flips the perspective.\n     *   True: You want the initialRouteName to load.\n     *   False: You do not want the initialRouteName to load.\n     */\n    rootPayload.params.initial = !withAnchor;\n  }\n\n  return {\n    type,\n    target: navigationState.key,\n    payload: {\n      // key: rootPayload.key,\n      name: rootPayload.screen,\n      params: rootPayload.params,\n    },\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}