{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNormalizedStatePath = exports.getRouteInfoFromState = void 0;\nvar getStateFromPath_forks_1 = require(\"./fork/getStateFromPath-forks\");\nfunction getRouteInfoFromState(getPathFromState, state, baseUrl) {\n  var _getPathFromState = getPathFromState(state, false),\n    path = _getPathFromState.path;\n  var qualified = getPathFromState(state, true);\n  return _objectSpread({\n    unstable_globalHref: path,\n    pathname: (0, getStateFromPath_forks_1.stripBaseUrl)(path, baseUrl).split('?')['0'],\n    isIndex: isIndexPath(state)\n  }, getNormalizedStatePath(qualified, baseUrl));\n}\nexports.getRouteInfoFromState = getRouteInfoFromState;\nfunction isIndexPath(state) {\n  var _state$index;\n  var route = state.routes[(_state$index = state.index) != null ? _state$index : state.routes.length - 1];\n  if (route.state) {\n    return isIndexPath(route.state);\n  }\n  if (route.params && 'screen' in route.params) {\n    return route.params.screen === 'index';\n  }\n  if (route.name.match(/.+\\/index$/)) return true;\n  return false;\n}\nfunction getNormalizedStatePath(_ref, baseUrl) {\n  var statePath = _ref.path,\n    params = _ref.params;\n  var _statePath$split = statePath.split('?'),\n    _statePath$split2 = _slicedToArray(_statePath$split, 1),\n    pathname = _statePath$split2[0];\n  return {\n    segments: (0, getStateFromPath_forks_1.stripBaseUrl)(pathname, baseUrl).split('/').filter(Boolean).map(decodeURIComponent),\n    params: decodeParams(params)\n  };\n}\nexports.getNormalizedStatePath = getNormalizedStatePath;\nfunction decodeParams(params) {\n  var parsed = {};\n  for (var _ref2 of Object.entries(params)) {\n    var _ref3 = _slicedToArray(_ref2, 2);\n    var key = _ref3[0];\n    var value = _ref3[1];\n    try {\n      if (key === 'params' && typeof value === 'object') {\n        parsed[key] = decodeParams(value);\n      } else if (Array.isArray(value)) {\n        parsed[key] = value.map(function (v) {\n          return decodeURIComponent(v);\n        });\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch (_unused) {\n      parsed[key] = value;\n    }\n  }\n  return parsed;\n}","map":{"version":3,"names":["getStateFromPath_forks_1","require","getRouteInfoFromState","getPathFromState","state","baseUrl","_getPathFromState","path","qualified","_objectSpread","unstable_globalHref","pathname","stripBaseUrl","split","isIndex","isIndexPath","getNormalizedStatePath","exports","_state$index","route","routes","index","length","params","screen","name","match","_ref","statePath","_statePath$split","_statePath$split2","_slicedToArray","segments","filter","Boolean","map","decodeURIComponent","decodeParams","parsed","_ref2","Object","entries","_ref3","key","value","Array","isArray","v","_unused"],"sources":["C:\\Users\\R User\\Documents\\software_dev\\BranchBuddy\\node_modules\\expo-router\\src\\LocationProvider.tsx"],"sourcesContent":["import { type State } from './fork/getPathFromState';\nimport { stripBaseUrl } from './fork/getStateFromPath-forks';\n\ntype SearchParams = Record<string, string | string[]>;\n\nexport type UrlObject = {\n  unstable_globalHref: string;\n  pathname: string;\n  readonly params: SearchParams;\n  segments: string[];\n  isIndex: boolean;\n};\n\nexport function getRouteInfoFromState(\n  getPathFromState: (state: State, asPath: boolean) => { path: string; params: any },\n  state: State,\n  baseUrl?: string\n): UrlObject {\n  const { path } = getPathFromState(state, false);\n  const qualified = getPathFromState(state, true);\n\n  return {\n    // TODO: This may have a predefined origin attached in the future.\n    unstable_globalHref: path,\n    pathname: stripBaseUrl(path, baseUrl).split('?')['0'],\n    isIndex: isIndexPath(state),\n    ...getNormalizedStatePath(qualified, baseUrl),\n  };\n}\n\nfunction isIndexPath(state: State) {\n  const route = state.routes[state.index ?? state.routes.length - 1];\n  if (route.state) {\n    return isIndexPath(route.state);\n  }\n\n  // Index routes on the same level as a layout do not have `index` in their name\n  if (route.params && 'screen' in route.params) {\n    return route.params.screen === 'index';\n  }\n\n  // The `params` key will not exist if there are no params\n  // So we need to do a positive lookahead to check if the route ends with /index\n  // Nested routes that are hoisted will have a name ending with /index\n  // e.g name could be /user/[id]/index\n  if (route.name.match(/.+\\/index$/)) return true;\n\n  // The state will either have params (because there are multiple _layout) or it will be hoisted with a name\n  // If we don't match the above cases, then it's not an index route\n\n  return false;\n}\n\n// TODO: Split up getPathFromState to return all this info at once.\nexport function getNormalizedStatePath(\n  {\n    path: statePath,\n    params,\n  }: {\n    path: string;\n    params: any;\n  },\n  baseUrl?: string\n): Pick<UrlObject, 'segments' | 'params'> {\n  const [pathname] = statePath.split('?');\n  return {\n    // Strip empty path at the start\n    segments: stripBaseUrl(pathname, baseUrl).split('/').filter(Boolean).map(decodeURIComponent),\n    // TODO: This is not efficient, we should generate based on the state instead\n    // of converting to string then back to object\n    params: decodeParams(params),\n  };\n}\n\nfunction decodeParams(params: Record<string, string>) {\n  const parsed: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(params)) {\n    try {\n      if (key === 'params' && typeof value === 'object') {\n        parsed[key] = decodeParams(value);\n      } else if (Array.isArray(value)) {\n        parsed[key] = value.map((v) => decodeURIComponent(v));\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch {\n      parsed[key] = value;\n    }\n  }\n\n  return parsed;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}