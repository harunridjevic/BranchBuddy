{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPathFromState = getPathFromState;\nvar queryString = _interopRequireWildcard(require(\"query-string\"));\nvar _getPatternParts = require(\"./getPatternParts.js\");\nvar _validatePathConfig = require(\"./validatePathConfig.js\");\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n    t = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n    return e ? t : r;\n  })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n  var t = _getRequireWildcardCache(r);\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n      __proto__: null\n    },\n    a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n  return n.default = e, t && t.set(e, n), n;\n}\nvar _getActiveRoute = function getActiveRoute(state) {\n  var route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n  if (route.state) {\n    return _getActiveRoute(route.state);\n  }\n  return route;\n};\nvar cachedNormalizedConfigs = new WeakMap();\nvar getNormalizedConfigs = function getNormalizedConfigs(options) {\n  if (!(options != null && options.screens)) return {};\n  var cached = cachedNormalizedConfigs.get(options == null ? void 0 : options.screens);\n  if (cached) return cached;\n  var normalizedConfigs = createNormalizedConfigs(options.screens);\n  cachedNormalizedConfigs.set(options.screens, normalizedConfigs);\n  return normalizedConfigs;\n};\nfunction getPathFromState(state, options) {\n  if (state == null) {\n    throw Error(`Got '${String(state)}' for the navigation state. You must pass a valid state object.`);\n  }\n  if (options) {\n    (0, _validatePathConfig.validatePathConfig)(options);\n  }\n  var configs = getNormalizedConfigs(options);\n  var path = '/';\n  var current = state;\n  var allParams = {};\n  var _loop = function _loop() {\n    var index = typeof current.index === 'number' ? current.index : 0;\n    var route = current.routes[index];\n    var parts;\n    var focusedParams;\n    var currentOptions = configs;\n    var focusedRoute = _getActiveRoute(state);\n    var nestedRouteNames = [];\n    var hasNext = true;\n    var _loop2 = function _loop2() {\n      parts = currentOptions[route.name].parts;\n      nestedRouteNames.push(route.name);\n      if (route.params) {\n        var _currentOptions$route, _parts2;\n        var stringify = (_currentOptions$route = currentOptions[route.name]) == null ? void 0 : _currentOptions$route.stringify;\n        var currentParams = Object.fromEntries(Object.entries(route.params).map(function (_ref4) {\n          var _ref5 = _slicedToArray(_ref4, 2),\n            key = _ref5[0],\n            value = _ref5[1];\n          return [key, stringify != null && stringify[key] ? stringify[key](value) : String(value)];\n        }));\n        if ((_parts2 = parts) != null && _parts2.length) {\n          Object.assign(allParams, currentParams);\n        }\n        if (focusedRoute === route) {\n          var _parts3;\n          focusedParams = _objectSpread({}, currentParams);\n          (_parts3 = parts) == null ? void 0 : _parts3.forEach(function (_ref6) {\n            var param = _ref6.param;\n            if (param) {\n              if (focusedParams) {\n                delete focusedParams[param];\n              }\n            }\n          });\n        }\n      }\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        var nextRoute = route.state.routes[index];\n        var nestedConfig = currentOptions[route.name].screens;\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          hasNext = false;\n        }\n      }\n    };\n    while (route.name in currentOptions && hasNext) {\n      _loop2();\n    }\n    if (currentOptions[route.name] !== undefined) {\n      var _parts;\n      path += (_parts = parts) == null ? void 0 : _parts.map(function (_ref) {\n        var segment = _ref.segment,\n          param = _ref.param,\n          optional = _ref.optional;\n        if (segment === '*') {\n          return route.name;\n        }\n        if (param) {\n          var value = allParams[param];\n          if (value === undefined && optional) {\n            return '';\n          }\n          return String(value).replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g, function (char) {\n            return encodeURIComponent(char);\n          });\n        }\n        return encodeURIComponent(segment);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n    if (!focusedParams && focusedRoute.params) {\n      focusedParams = Object.fromEntries(Object.entries(focusedRoute.params).map(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n          key = _ref3[0],\n          value = _ref3[1];\n        return [key, String(value)];\n      }));\n    }\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (var param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          delete focusedParams[param];\n        }\n      }\n      var query = queryString.stringify(focusedParams, {\n        sort: false\n      });\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n    current = route.state;\n  };\n  while (current) {\n    _loop();\n  }\n  if (options != null && options.path) {\n    path = `${options.path}/${path}`;\n  }\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  if (!path.startsWith('/')) {\n    path = `/${path}`;\n  }\n  return path;\n}\nvar createConfigItem = function createConfigItem(config, parentParts) {\n  if (typeof config === 'string') {\n    var _parts4 = (0, _getPatternParts.getPatternParts)(config);\n    if (parentParts) {\n      return {\n        parts: [].concat(_toConsumableArray(parentParts), _toConsumableArray(_parts4))\n      };\n    }\n    return {\n      parts: _parts4\n    };\n  }\n  if (config.exact && config.path === undefined) {\n    throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n  }\n  var parts = config.exact !== true ? [].concat(_toConsumableArray(parentParts || []), _toConsumableArray(config.path ? (0, _getPatternParts.getPatternParts)(config.path) : [])) : config.path ? (0, _getPatternParts.getPatternParts)(config.path) : undefined;\n  var screens = config.screens ? createNormalizedConfigs(config.screens, parts) : undefined;\n  return {\n    parts: parts,\n    stringify: config.stringify,\n    screens: screens\n  };\n};\nvar createNormalizedConfigs = function createNormalizedConfigs(options, parts) {\n  return Object.fromEntries(Object.entries(options).map(function (_ref7) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n      name = _ref8[0],\n      c = _ref8[1];\n    var result = createConfigItem(c, parts);\n    return [name, result];\n  }));\n};","map":{"version":3,"names":["queryString","_interopRequireWildcard","require","_getPatternParts","_validatePathConfig","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","getActiveRoute","state","route","index","routes","length","cachedNormalizedConfigs","getNormalizedConfigs","options","screens","cached","normalizedConfigs","createNormalizedConfigs","getPathFromState","Error","String","validatePathConfig","configs","path","current","allParams","_loop","parts","focusedParams","currentOptions","focusedRoute","nestedRouteNames","hasNext","_loop2","name","push","params","_currentOptions$route","_parts2","stringify","currentParams","fromEntries","entries","map","_ref4","_ref5","_slicedToArray","key","value","assign","_parts3","_objectSpread","forEach","_ref6","param","undefined","nextRoute","nestedConfig","_parts","_ref","segment","optional","replace","char","encodeURIComponent","join","_ref2","_ref3","query","sort","startsWith","createConfigItem","config","parentParts","getPatternParts","concat","_toConsumableArray","exact","_ref7","_ref8","c","result"],"sources":["C:\\Users\\R User\\Documents\\software_dev\\BranchBuddy\\node_modules\\@react-navigation\\core\\src\\getPathFromState.tsx"],"sourcesContent":["import type {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport * as queryString from 'query-string';\n\nimport { getPatternParts, type PatternPart } from './getPatternParts';\nimport type { PathConfig, PathConfigMap } from './types';\nimport { validatePathConfig } from './validatePathConfig';\n\ntype Options<ParamList extends {}> = {\n  path?: string;\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: unknown) => string>;\n\ntype ConfigItem = {\n  parts?: PatternPart[];\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\nconst cachedNormalizedConfigs = new WeakMap<\n  PathConfigMap<{}>,\n  Record<string, ConfigItem>\n>();\n\nconst getNormalizedConfigs = (options?: Options<{}>) => {\n  if (!options?.screens) return {};\n\n  const cached = cachedNormalizedConfigs.get(options?.screens);\n\n  if (cached) return cached;\n\n  const normalizedConfigs = createNormalizedConfigs(options.screens);\n\n  cachedNormalizedConfigs.set(options.screens, normalizedConfigs);\n\n  return normalizedConfigs;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport function getPathFromState<ParamList extends {}>(\n  state: State,\n  options?: Options<ParamList>\n): string {\n  if (state == null) {\n    throw Error(\n      `Got '${String(state)}' for the navigation state. You must pass a valid state object.`\n    );\n  }\n\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const configs = getNormalizedConfigs(options);\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, string> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let parts: PatternPart[] | undefined;\n\n    let focusedParams: Record<string, string> | undefined;\n    let currentOptions = configs;\n\n    const focusedRoute = getActiveRoute(state);\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    const nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      parts = currentOptions[route.name].parts;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        const currentParams = Object.fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (parts?.length) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          parts\n            // eslint-disable-next-line no-loop-func\n            ?.forEach(({ param }) => {\n              if (param) {\n                // Remove the params present in the pattern since we'll only use the rest for query string\n                if (focusedParams) {\n                  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                  delete focusedParams[param];\n                }\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += parts\n        ?.map(({ segment, param, optional }) => {\n          // We don't know what to show for wildcard patterns\n          // Showing the route name seems ok, though whatever we show here will be incorrect\n          // Since the page doesn't actually exist\n          if (segment === '*') {\n            return route.name;\n          }\n\n          // If the path has a pattern for a param, put the param in the path\n          if (param) {\n            const value = allParams[param];\n\n            if (value === undefined && optional) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            // Valid characters according to\n            // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)\n            return String(value).replace(\n              /[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g,\n              (char) => encodeURIComponent(char)\n            );\n          }\n\n          return encodeURIComponent(segment);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams && focusedRoute.params) {\n      focusedParams = Object.fromEntries(\n        Object.entries(focusedRoute.params).map(([key, value]) => [\n          key,\n          String(value),\n        ])\n      );\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (const param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      const query = queryString.stringify(focusedParams, { sort: false });\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Include the root path if specified\n  if (options?.path) {\n    path = `${options.path}/${path}`;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  // If path doesn't start with a slash, add it\n  // This makes sure that history.pushState will update the path correctly instead of appending\n  if (!path.startsWith('/')) {\n    path = `/${path}`;\n  }\n\n  return path;\n}\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentParts?: PatternPart[]\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const parts = getPatternParts(config);\n\n    if (parentParts) {\n      return { parts: [...parentParts, ...parts] };\n    }\n\n    return { parts };\n  }\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const parts =\n    config.exact !== true\n      ? [\n          ...(parentParts || []),\n          ...(config.path ? getPatternParts(config.path) : []),\n        ]\n      : config.path\n        ? getPatternParts(config.path)\n        : undefined;\n\n  const screens = config.screens\n    ? createNormalizedConfigs(config.screens, parts)\n    : undefined;\n\n  return {\n    parts,\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  parts?: PatternPart[]\n): Record<string, ConfigItem> =>\n  Object.fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, parts);\n\n      return [name, result];\n    })\n  );\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}