{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _excluded = [\"screen\", \"if\"],\n  _excluded2 = [\"screens\", \"groups\"],\n  _excluded3 = [\"if\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createComponentForStaticNavigation = createComponentForStaticNavigation;\nexports.createPathConfigForStaticNavigation = createPathConfigForStaticNavigation;\nvar _react = _interopRequireWildcard(require(\"react\"));\nvar React = _react;\nvar _reactIs = require(\"react-is\");\nvar _useRoute = require(\"./useRoute.js\");\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n    t = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n    return e ? t : r;\n  })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n  var t = _getRequireWildcardCache(r);\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n      __proto__: null\n    },\n    a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n  return n.default = e, t && t.set(e, n), n;\n}\nvar MemoizedScreen = React.memo(function (_ref) {\n  var component = _ref.component;\n  var route = (0, _useRoute.useRoute)();\n  var children = React.createElement(component, {\n    route: route\n  });\n  return children;\n});\nMemoizedScreen.displayName = 'Memo(Screen)';\nvar getItemsFromScreens = function getItemsFromScreens(Screen, screens) {\n  return Object.entries(screens).map(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n      name = _ref3[0],\n      item = _ref3[1];\n    var component;\n    var props = {};\n    var useIf;\n    var isNavigator = false;\n    if ('screen' in item) {\n      var screen = item.screen,\n        _if = item.if,\n        rest = _objectWithoutProperties(item, _excluded);\n      useIf = _if;\n      props = rest;\n      if ((0, _reactIs.isValidElementType)(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(screen, `${name}Navigator`);\n      }\n    } else if ((0, _reactIs.isValidElementType)(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n    if (component == null) {\n      throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);\n    }\n    var element = isNavigator ? (React.createElement(component, {})) : (0, _jsxRuntime.jsx)(MemoizedScreen, {\n      component: component\n    });\n    return function () {\n      var shouldRender = useIf == null || useIf();\n      if (!shouldRender) {\n        return null;\n      }\n      return (0, _jsxRuntime.jsx)(Screen, _objectSpread(_objectSpread({\n        name: name\n      }, props), {}, {\n        children: function children() {\n          return element;\n        }\n      }), name);\n    };\n  });\n};\nfunction createComponentForStaticNavigation(tree, displayName) {\n  var Navigator = tree.Navigator,\n    Group = tree.Group,\n    Screen = tree.Screen,\n    config = tree.config;\n  var screens = config.screens,\n    groups = config.groups,\n    rest = _objectWithoutProperties(config, _excluded2);\n  if (screens == null && groups == null) {\n    throw new Error(\"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\");\n  }\n  var items = [];\n  for (var key in config) {\n    if (key === 'screens' && screens) {\n      items.push.apply(items, _toConsumableArray(getItemsFromScreens(Screen, screens)));\n    }\n    if (key === 'groups' && groups) {\n      items.push.apply(items, _toConsumableArray(Object.entries(groups).map(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n          key = _ref6[0],\n          _ref4 = _ref6[1];\n        var useIf = _ref4.if,\n          group = _objectWithoutProperties(_ref4, _excluded3);\n        var groupItems = getItemsFromScreens(Screen, group.screens);\n        return function () {\n          var children = groupItems.map(function (item) {\n            return item();\n          });\n          var shouldRender = useIf == null || useIf();\n          if (!shouldRender) {\n            return null;\n          }\n          return (0, _react.createElement)(Group, _objectSpread(_objectSpread({\n            navigationKey: key\n          }, group), {}, {\n            key: key\n          }), children);\n        };\n      })));\n    }\n  }\n  var NavigatorComponent = function NavigatorComponent() {\n    var children = items.map(function (item) {\n      return item();\n    });\n    return (0, _jsxRuntime.jsx)(Navigator, _objectSpread(_objectSpread({}, rest), {}, {\n      children: children\n    }));\n  };\n  NavigatorComponent.displayName = displayName;\n  return NavigatorComponent;\n}\nfunction createPathConfigForStaticNavigation(tree, options, auto) {\n  var initialScreenConfig;\n  var _createPathConfigForTree = function createPathConfigForTree(t, o, skipInitialDetection) {\n    var createPathConfigForScreens = function createPathConfigForScreens(screens, initialRouteName) {\n      return Object.fromEntries(Object.entries(screens).sort(function (_ref7, _ref8) {\n        var _ref9 = _slicedToArray(_ref7, 1),\n          a = _ref9[0];\n        var _ref10 = _slicedToArray(_ref8, 1),\n          b = _ref10[0];\n        if (a === initialRouteName) {\n          return -1;\n        }\n        if (b === initialRouteName) {\n          return 1;\n        }\n        return 0;\n      }).map(function (_ref11) {\n        var _ref12 = _slicedToArray(_ref11, 2),\n          key = _ref12[0],\n          item = _ref12[1];\n        var screenConfig = {};\n        if ('linking' in item) {\n          if (typeof item.linking === 'string') {\n            screenConfig.path = item.linking;\n          } else {\n            Object.assign(screenConfig, item.linking);\n          }\n          if (typeof screenConfig.path === 'string') {\n            screenConfig.path = screenConfig.path.split('/').filter(Boolean).join('/');\n          }\n        }\n        var screens;\n        var skipInitialDetectionInChild = skipInitialDetection || screenConfig.path != null && screenConfig.path !== '';\n        if ('config' in item) {\n          screens = _createPathConfigForTree(item, undefined, skipInitialDetectionInChild);\n        } else if ('screen' in item && 'config' in item.screen && (item.screen.config.screens || item.screen.config.groups)) {\n          screens = _createPathConfigForTree(item.screen, undefined, skipInitialDetectionInChild);\n        }\n        if (screens) {\n          screenConfig.screens = screens;\n        }\n        if (auto && !screenConfig.screens && !('linking' in item && item.linking == null)) {\n          if (screenConfig.path != null) {\n            if (!skipInitialDetection && screenConfig.path === '') {\n              initialScreenConfig = undefined;\n            }\n          } else {\n            if (!skipInitialDetection && initialScreenConfig == null) {\n              initialScreenConfig = screenConfig;\n            }\n            screenConfig.path = key.replace(/([A-Z]+)/g, '-$1').replace(/^-/, '').toLowerCase();\n          }\n        }\n        return [key, screenConfig];\n      }).filter(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 2),\n          screen = _ref14[1];\n        return Object.keys(screen).length > 0;\n      }));\n    };\n    var screens = {};\n    for (var key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        var _o$initialRouteName;\n        Object.assign(screens, createPathConfigForScreens(t.config.screens, (_o$initialRouteName = o == null ? void 0 : o.initialRouteName) != null ? _o$initialRouteName : t.config.initialRouteName));\n      }\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(function (_ref15) {\n          var _o$initialRouteName2;\n          var _ref16 = _slicedToArray(_ref15, 2),\n            group = _ref16[1];\n          Object.assign(screens, createPathConfigForScreens(group.screens, (_o$initialRouteName2 = o == null ? void 0 : o.initialRouteName) != null ? _o$initialRouteName2 : t.config.initialRouteName));\n        });\n      }\n    }\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n    return screens;\n  };\n  var screens = _createPathConfigForTree(tree, options, false);\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n  return screens;\n}","map":{"version":3,"names":["_react","_interopRequireWildcard","require","React","_reactIs","_useRoute","_jsxRuntime","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","MemoizedScreen","memo","_ref","component","route","useRoute","children","createElement","displayName","getItemsFromScreens","Screen","screens","entries","map","_ref2","_ref3","_slicedToArray","name","item","props","useIf","isNavigator","screen","_if","if","rest","_objectWithoutProperties","_excluded","isValidElementType","createComponentForStaticNavigation","Error","element","jsx","shouldRender","_objectSpread","tree","Navigator","Group","config","groups","_excluded2","items","key","push","apply","_toConsumableArray","_ref5","_ref6","_ref4","group","_excluded3","groupItems","navigationKey","NavigatorComponent","createPathConfigForStaticNavigation","options","auto","initialScreenConfig","createPathConfigForTree","o","skipInitialDetection","createPathConfigForScreens","initialRouteName","fromEntries","sort","_ref7","_ref8","_ref9","_ref10","b","_ref11","_ref12","screenConfig","linking","path","assign","split","filter","Boolean","join","skipInitialDetectionInChild","undefined","replace","toLowerCase","_ref13","_ref14","keys","length","_o$initialRouteName","forEach","_ref15","_o$initialRouteName2","_ref16"],"sources":["C:\\Users\\R User\\Documents\\software_dev\\BranchBuddy\\node_modules\\@react-navigation\\core\\src\\StaticNavigation.tsx"],"sourcesContent":["import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\n\nimport type {\n  DefaultNavigatorOptions,\n  EventMapBase,\n  NavigationListBase,\n  NavigatorScreenParams,\n  NavigatorTypeBagBase,\n  PathConfig,\n  RouteConfigComponent,\n  RouteConfigProps,\n  RouteGroupConfig,\n} from './types';\nimport { useRoute } from './useRoute';\n\n/**\n * Flatten a type to remove all type alias names, unions etc.\n * This will show a plain object when hovering over the type.\n */\ntype FlatType<T> = { [K in keyof T]: T[K] } & {};\n\n/**\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype KeysOf<T> = T extends {} ? keyof T : never;\n\n/**\n * We get a union type when using keyof, but we want an intersection instead.\n * https://stackoverflow.com/a/50375286/1665026\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\ntype UnknownToUndefined<T> = unknown extends T ? undefined : T;\n\ntype ParamsForScreenComponent<T> = T extends {\n  screen: React.ComponentType<{ route: { params: infer P } }>;\n}\n  ? P\n  : T extends React.ComponentType<{ route: { params: infer P } }>\n    ? P\n    : undefined;\n\ntype ParamsForScreen<T> = T extends { screen: StaticNavigation<any, any, any> }\n  ? NavigatorScreenParams<StaticParamList<T['screen']>> | undefined\n  : T extends StaticNavigation<any, any, any>\n    ? NavigatorScreenParams<StaticParamList<T>> | undefined\n    : UnknownToUndefined<ParamsForScreenComponent<T>>;\n\ntype ParamListForScreens<Screens> = {\n  [Key in KeysOf<Screens>]: ParamsForScreen<Screens[Key]>;\n};\n\ntype ParamListForGroups<\n  Groups extends\n    | Readonly<{\n        [key: string]: {\n          screens: StaticConfigScreens<\n            ParamListBase,\n            NavigationState,\n            {},\n            EventMapBase,\n            any\n          >;\n        };\n      }>\n    | undefined,\n> = Groups extends {\n  [key: string]: {\n    screens: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      any\n    >;\n  };\n}\n  ? ParamListForScreens<UnionToIntersection<Groups[keyof Groups]['screens']>>\n  : {};\n\ntype StaticRouteConfig<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  Navigation,\n> = RouteConfigProps<\n  ParamList,\n  RouteName,\n  State,\n  ScreenOptions,\n  EventMap,\n  Navigation\n> &\n  RouteConfigComponent<ParamList, RouteName>;\n\ntype StaticConfigScreens<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = {\n  [RouteName in keyof ParamList]:\n    | React.ComponentType<any>\n    | StaticNavigation<any, any, any>\n    | (Omit<\n        StaticRouteConfig<\n          ParamList,\n          RouteName,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList[RouteName]\n        >,\n        'name' | 'component' | 'getComponent' | 'children'\n      > & {\n        /**\n         * Callback to determine whether the screen should be rendered or not.\n         * This can be useful for conditional rendering of screens,\n         * e.g. - if you want to render a different screen for logged in users.\n         *\n         * You can use a custom hook to use custom logic to determine the return value.\n         *\n         * @example\n         * ```js\n         * if: useIsLoggedIn\n         * ```\n         */\n        if?: () => boolean;\n        /**\n         * Linking config for the screen.\n         * This can be a string to specify the path, or an object with more options.\n         *\n         * @example\n         * ```js\n         * linking: {\n         *   path: 'profile/:id',\n         *   exact: true,\n         * },\n         * ```\n         */\n        linking?: PathConfig<ParamList> | string;\n        /**\n         * Static navigation config or Component to render for the screen.\n         */\n        screen: StaticNavigation<any, any, any> | React.ComponentType<any>;\n      });\n};\n\ntype GroupConfig<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n> = Omit<\n  RouteGroupConfig<ParamList, ScreenOptions, NavigationList[keyof ParamList]>,\n  'screens' | 'children'\n> & {\n  /**\n   * Callback to determine whether the screens in the group should be rendered or not.\n   * This can be useful for conditional rendering of group of screens.\n   */\n  if?: () => boolean;\n  /**\n   * Static navigation config or Component to render for the screen.\n   */\n  screens: StaticConfigScreens<\n    ParamList,\n    State,\n    ScreenOptions,\n    EventMap,\n    NavigationList\n  >;\n};\n\nexport type StaticConfig<Bag extends NavigatorTypeBagBase> =\n  StaticConfigInternal<\n    Bag['ParamList'],\n    Bag['NavigatorID'],\n    Bag['State'],\n    Bag['ScreenOptions'],\n    Bag['EventMap'],\n    Bag['NavigationList'],\n    Bag['Navigator']\n  >;\n\ntype StaticConfigInternal<\n  ParamList extends ParamListBase,\n  NavigatorID extends string | undefined,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigationList extends NavigationListBase<ParamList>,\n  Navigator extends React.ComponentType<any>,\n> = Omit<\n  Omit<\n    React.ComponentProps<Navigator>,\n    keyof DefaultNavigatorOptions<\n      ParamListBase,\n      string | undefined,\n      NavigationState,\n      {},\n      EventMapBase,\n      NavigationList[keyof ParamList]\n    >\n  > &\n    DefaultNavigatorOptions<\n      ParamList,\n      NavigatorID,\n      State,\n      ScreenOptions,\n      EventMap,\n      NavigationList[keyof ParamList]\n    >,\n  'screens' | 'children'\n> &\n  (\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups?: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n    | {\n        /**\n         * Screens to render in the navigator and their configuration.\n         */\n        screens?: StaticConfigScreens<\n          ParamList,\n          State,\n          ScreenOptions,\n          EventMap,\n          NavigationList\n        >;\n        /**\n         * Groups of screens to render in the navigator and their configuration.\n         */\n        groups: {\n          [key: string]: GroupConfig<\n            ParamList,\n            State,\n            ScreenOptions,\n            EventMap,\n            NavigationList\n          >;\n        };\n      }\n  );\n\n/**\n * Props for a screen component which is rendered by a static navigator.\n * Takes the route params as a generic argument.\n */\nexport type StaticScreenProps<T extends Record<string, unknown> | undefined> = {\n  route: {\n    params: T;\n  };\n};\n\n/**\n * Infer the param list from the static navigation config.\n */\nexport type StaticParamList<\n  T extends {\n    readonly config: {\n      readonly screens?: Record<string, any>;\n      readonly groups?: {\n        [key: string]: {\n          screens: Record<string, any>;\n        };\n      };\n    };\n  },\n> = FlatType<\n  ParamListForScreens<T['config']['screens']> &\n    ParamListForGroups<T['config']['groups']>\n>;\n\nexport type StaticNavigation<NavigatorProps, GroupProps, ScreenProps> = {\n  Navigator: React.ComponentType<NavigatorProps>;\n  Group: React.ComponentType<GroupProps>;\n  Screen: React.ComponentType<ScreenProps>;\n  config: StaticConfig<NavigatorTypeBagBase>;\n};\n\nconst MemoizedScreen = React.memo(\n  <T extends React.ComponentType<any>>({ component }: { component: T }) => {\n    const route = useRoute();\n    const children = React.createElement(component, { route });\n\n    return children;\n  }\n);\n\nMemoizedScreen.displayName = 'Memo(Screen)';\n\nconst getItemsFromScreens = (\n  Screen: React.ComponentType<any>,\n  screens: StaticConfigScreens<any, any, any, any, any>\n) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component: React.ComponentType<any> | undefined;\n    let props: {} = {};\n    let useIf: (() => boolean) | undefined;\n\n    let isNavigator = false;\n\n    if ('screen' in item) {\n      const { screen, if: _if, ...rest } = item;\n\n      useIf = _if;\n      props = rest;\n\n      if (isValidElementType(screen)) {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(\n          screen,\n          `${name}Navigator`\n        );\n      }\n    } else if (isValidElementType(item)) {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n\n    if (component == null) {\n      throw new Error(\n        `Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`\n      );\n    }\n\n    const element = isNavigator ? (\n      React.createElement(component, {})\n    ) : (\n      <MemoizedScreen component={component} />\n    );\n\n    return () => {\n      const shouldRender = useIf == null || useIf();\n\n      if (!shouldRender) {\n        return null;\n      }\n\n      return (\n        <Screen key={name} name={name} {...props}>\n          {() => element}\n        </Screen>\n      );\n    };\n  });\n};\n\n/**\n * Create a component that renders a navigator based on the static configuration.\n *\n * @param tree Static navigation config.\n * @param displayName Name of the component to be displayed in React DevTools.\n * @returns A component which renders the navigator.\n */\nexport function createComponentForStaticNavigation(\n  tree: StaticNavigation<any, any, any>,\n  displayName: string\n): React.ComponentType<{}> {\n  const { Navigator, Group, Screen, config } = tree;\n  const { screens, groups, ...rest } = config;\n\n  if (screens == null && groups == null) {\n    throw new Error(\n      \"Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.\"\n    );\n  }\n\n  const items: (() => JSX.Element | null)[] = [];\n\n  // Loop through the config to find screens and groups\n  // So we add the screens and groups in the same order as they are defined\n  for (const key in config) {\n    if (key === 'screens' && screens) {\n      items.push(...getItemsFromScreens(Screen, screens));\n    }\n\n    if (key === 'groups' && groups) {\n      items.push(\n        ...Object.entries(groups).map(([key, { if: useIf, ...group }]) => {\n          const groupItems = getItemsFromScreens(Screen, group.screens);\n\n          return () => {\n            // Call unconditionally since screen configs may contain `useIf` hooks\n            const children = groupItems.map((item) => item());\n\n            const shouldRender = useIf == null || useIf();\n\n            if (!shouldRender) {\n              return null;\n            }\n\n            return (\n              <Group navigationKey={key} {...group} key={key}>\n                {children}\n              </Group>\n            );\n          };\n        })\n      );\n    }\n  }\n\n  const NavigatorComponent = () => {\n    const children = items.map((item) => item());\n\n    return <Navigator {...rest}>{children}</Navigator>;\n  };\n\n  NavigatorComponent.displayName = displayName;\n\n  return NavigatorComponent;\n}\n\ntype TreeForPathConfig = {\n  config: {\n    initialRouteName?: string;\n    screens?: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase,\n      Record<string, unknown>\n    >;\n    groups?: {\n      [key: string]: {\n        screens: StaticConfigScreens<\n          ParamListBase,\n          NavigationState,\n          {},\n          EventMapBase,\n          Record<string, unknown>\n        >;\n      };\n    };\n  };\n};\n\n/**\n * Create a path config object from a static navigation config for deep linking.\n *\n * @param tree Static navigation config.\n * @param options Additional options from `linking.config`.\n * @param auto Whether to automatically generate paths for leaf screens.\n * @returns Path config object to use in linking config.\n *\n * @example\n * ```js\n * const config = {\n *   screens: {\n *     Home: {\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\n *     },\n *   },\n * };\n * ```\n */\nexport function createPathConfigForStaticNavigation(\n  tree: TreeForPathConfig,\n  options?: {\n    initialRouteName?: string;\n  },\n  auto?: boolean\n) {\n  let initialScreenConfig: PathConfig<ParamListBase> | undefined;\n\n  const createPathConfigForTree = (\n    t: TreeForPathConfig,\n    o: { initialRouteName?: string } | undefined,\n    // If a screen is a leaf node, but inside a screen with path,\n    // It should not be used for initial detection\n    skipInitialDetection: boolean\n  ) => {\n    const createPathConfigForScreens = (\n      screens: StaticConfigScreens<\n        ParamListBase,\n        NavigationState,\n        {},\n        EventMapBase,\n        Record<string, unknown>\n      >,\n      initialRouteName: string | undefined\n    ) => {\n      return Object.fromEntries(\n        Object.entries(screens)\n          // Re-order to move the initial route to the front\n          // This way we can detect the initial route correctly\n          .sort(([a], [b]) => {\n            if (a === initialRouteName) {\n              return -1;\n            }\n\n            if (b === initialRouteName) {\n              return 1;\n            }\n\n            return 0;\n          })\n          .map(([key, item]) => {\n            const screenConfig: PathConfig<ParamListBase> = {};\n\n            if ('linking' in item) {\n              if (typeof item.linking === 'string') {\n                screenConfig.path = item.linking;\n              } else {\n                Object.assign(screenConfig, item.linking);\n              }\n\n              if (typeof screenConfig.path === 'string') {\n                // Normalize the path to remove leading and trailing slashes\n                screenConfig.path = screenConfig.path\n                  .split('/')\n                  .filter(Boolean)\n                  .join('/');\n              }\n            }\n\n            let screens;\n\n            const skipInitialDetectionInChild =\n              skipInitialDetection ||\n              (screenConfig.path != null && screenConfig.path !== '');\n\n            if ('config' in item) {\n              screens = createPathConfigForTree(\n                item,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            } else if (\n              'screen' in item &&\n              'config' in item.screen &&\n              (item.screen.config.screens || item.screen.config.groups)\n            ) {\n              screens = createPathConfigForTree(\n                item.screen,\n                undefined,\n                skipInitialDetectionInChild\n              );\n            }\n\n            if (screens) {\n              screenConfig.screens = screens;\n            }\n\n            if (\n              auto &&\n              !screenConfig.screens &&\n              // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly\n              !('linking' in item && item.linking == null)\n            ) {\n              if (screenConfig.path != null) {\n                if (!skipInitialDetection && screenConfig.path === '') {\n                  // We encounter a leaf screen with empty path,\n                  // Clear the initial screen config as it's not needed anymore\n                  initialScreenConfig = undefined;\n                }\n              } else {\n                if (!skipInitialDetection && initialScreenConfig == null) {\n                  initialScreenConfig = screenConfig;\n                }\n\n                screenConfig.path = key\n                  .replace(/([A-Z]+)/g, '-$1')\n                  .replace(/^-/, '')\n                  .toLowerCase();\n              }\n            }\n\n            return [key, screenConfig] as const;\n          })\n          .filter(([, screen]) => Object.keys(screen).length > 0)\n      );\n    };\n\n    const screens = {};\n\n    // Loop through the config to find screens and groups\n    // So we add the screens and groups in the same order as they are defined\n    for (const key in t.config) {\n      if (key === 'screens' && t.config.screens) {\n        Object.assign(\n          screens,\n          createPathConfigForScreens(\n            t.config.screens,\n            o?.initialRouteName ?? t.config.initialRouteName\n          )\n        );\n      }\n\n      if (key === 'groups' && t.config.groups) {\n        Object.entries(t.config.groups).forEach(([, group]) => {\n          Object.assign(\n            screens,\n            createPathConfigForScreens(\n              group.screens,\n              o?.initialRouteName ?? t.config.initialRouteName\n            )\n          );\n        });\n      }\n    }\n\n    if (Object.keys(screens).length === 0) {\n      return undefined;\n    }\n\n    return screens;\n  };\n\n  const screens = createPathConfigForTree(tree, options, false);\n\n  if (auto && initialScreenConfig) {\n    initialScreenConfig.path = '';\n  }\n\n  return screens;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}