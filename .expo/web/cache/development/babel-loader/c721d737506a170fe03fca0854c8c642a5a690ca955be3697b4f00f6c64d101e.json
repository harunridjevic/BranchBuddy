{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateDynamic = exports.extrapolateGroups = exports.getIgnoreList = exports.getRoutes = void 0;\nvar matchers_1 = require(\"./matchers\");\nvar validPlatforms = new Set(['android', 'ios', 'native', 'web']);\nfunction getRoutes(contextModule, options) {\n  var directoryTree = getDirectoryTree(contextModule, options);\n  if (!directoryTree) {\n    return null;\n  }\n  var rootNode = flattenDirectoryTreeToRoutes(directoryTree, options);\n  if (!options.ignoreEntryPoints) {\n    crawlAndAppendInitialRoutesAndEntryFiles(rootNode, options);\n  }\n  return rootNode;\n}\nexports.getRoutes = getRoutes;\nfunction getDirectoryTree(contextModule, options) {\n  var importMode = options.importMode || process.env.EXPO_ROUTER_IMPORT_MODE;\n  var ignoreList = [/^\\.\\/\\+(html|native-intent)\\.[tj]sx?$/];\n  if (options.ignore) {\n    ignoreList.push.apply(ignoreList, _toConsumableArray(options.ignore));\n  }\n  if (!options.preserveApiRoutes) {\n    ignoreList.push(/\\+api\\.[tj]sx?$/);\n  }\n  var rootDirectory = {\n    files: new Map(),\n    subdirectories: new Map()\n  };\n  var hasRoutes = false;\n  var isValid = false;\n  var _loop = function _loop(filePath) {\n      if (ignoreList.some(function (regex) {\n        return regex.test(filePath);\n      })) {\n        return 0;\n      }\n      isValid = true;\n      var meta = getFileMeta(filePath, options);\n      if (meta.specificity < 0) {\n        return 0;\n      }\n      var node = {\n        type: meta.isApi ? 'api' : meta.isLayout ? 'layout' : 'route',\n        loadRoute: function loadRoute() {\n          var routeModule;\n          if (options.ignoreRequireErrors) {\n            try {\n              routeModule = contextModule(filePath);\n            } catch (_unused) {\n              routeModule = {};\n            }\n          } else {\n            routeModule = contextModule(filePath);\n          }\n          if (process.env.NODE_ENV === 'development' && importMode === 'sync') {\n            var _routeModule;\n            if (routeModule instanceof Promise) {\n              throw new Error(`Route \"${filePath}\" cannot be a promise when async routes is disabled.`);\n            }\n            var defaultExport = (_routeModule = routeModule) == null ? void 0 : _routeModule.default;\n            if (defaultExport instanceof Promise) {\n              throw new Error(`The default export from route \"${filePath}\" is a promise. Ensure the React Component does not use async or promises.`);\n            }\n            if (defaultExport instanceof Function && defaultExport.constructor.name === 'AsyncFunction') {\n              throw new Error(`The default export from route \"${filePath}\" is an async function. Ensure the React Component does not use async or promises.`);\n            }\n          }\n          return routeModule;\n        },\n        contextKey: filePath,\n        route: '',\n        dynamic: null,\n        children: []\n      };\n      if (process.env.NODE_ENV === 'development') {\n        if (node.type !== 'api' && importMode === 'sync') {\n          var routeItem = node.loadRoute();\n          var route = routeItem == null ? void 0 : routeItem.default;\n          if (route == null) {\n            console.warn(`Route \"${filePath}\" is missing the required default export. Ensure a React component is exported as default.`);\n            return 0;\n          }\n          if (['boolean', 'number', 'string'].includes(typeof route)) {\n            throw new Error(`The default export from route \"${filePath}\" is an unsupported type: \"${typeof route}\". Only React Components are supported as default exports from route files.`);\n          }\n        }\n      }\n      for (var _route of extrapolateGroups(meta.route)) {\n        var subdirectoryParts = _route.split('/').slice(0, -1);\n        var directory = rootDirectory;\n        for (var part of subdirectoryParts) {\n          var subDirectory = directory.subdirectories.get(part);\n          if (!subDirectory) {\n            subDirectory = {\n              files: new Map(),\n              subdirectories: new Map()\n            };\n            directory.subdirectories.set(part, subDirectory);\n          }\n          directory = subDirectory;\n        }\n        node = _objectSpread(_objectSpread({}, node), {}, {\n          route: _route\n        });\n        if (meta.isLayout) {\n          directory.layout ??= [];\n          var existing = directory.layout[meta.specificity];\n          if (existing) {\n            if (process.env.NODE_ENV !== 'production') {\n              throw new Error(`The layouts \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${_route}\". Please remove or rename one of these files.`);\n            }\n          } else {\n            node = getLayoutNode(node, options);\n            directory.layout[meta.specificity] = node;\n          }\n        } else if (meta.isApi) {\n          var fileKey = `${_route}+api`;\n          var nodes = directory.files.get(fileKey);\n          if (!nodes) {\n            nodes = [];\n            directory.files.set(fileKey, nodes);\n          }\n          var _existing = nodes[0];\n          if (_existing) {\n            if (process.env.NODE_ENV !== 'production') {\n              throw new Error(`The API route file \"${filePath}\" and \"${_existing.contextKey}\" conflict on the route \"/${_route}\". Please remove or rename one of these files.`);\n            }\n          } else {\n            nodes[0] = node;\n          }\n        } else {\n          var _nodes = directory.files.get(_route);\n          if (!_nodes) {\n            _nodes = [];\n            directory.files.set(_route, _nodes);\n          }\n          var _existing2 = _nodes[meta.specificity];\n          if (_existing2) {\n            if (process.env.NODE_ENV !== 'production') {\n              throw new Error(`The route files \"${filePath}\" and \"${_existing2.contextKey}\" conflict on the route \"/${_route}\". Please remove or rename one of these files.`);\n            }\n          } else {\n            hasRoutes ||= true;\n            _nodes[meta.specificity] = node;\n          }\n        }\n      }\n    },\n    _ret;\n  for (var filePath of contextModule.keys()) {\n    _ret = _loop(filePath);\n    if (_ret === 0) continue;\n  }\n  if (!isValid) {\n    return null;\n  }\n  if (!rootDirectory.layout) {\n    rootDirectory.layout = [options.getSystemRoute({\n      type: 'layout',\n      route: ''\n    })];\n  }\n  if (!options.skipGenerated) {\n    if (hasRoutes && options.sitemap !== false) {\n      appendSitemapRoute(rootDirectory, options);\n    }\n    if (options.notFound !== false) {\n      appendNotFoundRoute(rootDirectory, options);\n    }\n  }\n  return rootDirectory;\n}\nfunction flattenDirectoryTreeToRoutes(directory, options, layout) {\n  var pathToRemove = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n  if (directory.layout) {\n    var previousLayout = layout;\n    layout = getMostSpecific(directory.layout);\n    if (previousLayout) {\n      previousLayout.children.push(layout);\n    }\n    if (options.internal_stripLoadRoute) {\n      delete layout.loadRoute;\n    }\n    var newRoute = layout.route.replace(pathToRemove, '');\n    pathToRemove = layout.route ? `${layout.route}/` : '';\n    layout.route = newRoute;\n    layout.dynamic = generateDynamic(layout.contextKey.slice(0));\n  }\n  if (!layout) throw new Error('Expo Router Internal Error: No nearest layout');\n  for (var routes of directory.files.values()) {\n    var routeNode = getMostSpecific(routes);\n    routeNode.route = routeNode.route.replace(pathToRemove, '');\n    routeNode.dynamic = generateDynamic(routeNode.route);\n    if (options.internal_stripLoadRoute) {\n      delete routeNode.loadRoute;\n    }\n    layout.children.push(routeNode);\n  }\n  for (var child of directory.subdirectories.values()) {\n    flattenDirectoryTreeToRoutes(child, options, layout, pathToRemove);\n  }\n  return layout;\n}\nfunction getFileMeta(key, options) {\n  var _options$platformRout;\n  key = key.replace(/^\\.\\//, '');\n  var parts = key.split('/');\n  var route = (0, matchers_1.removeSupportedExtensions)(key);\n  var filename = parts[parts.length - 1];\n  var _split = (0, matchers_1.removeSupportedExtensions)(filename).split('.'),\n    _split2 = _slicedToArray(_split, 2),\n    filenameWithoutExtensions = _split2[0],\n    platformExtension = _split2[1];\n  var isLayout = filenameWithoutExtensions === '_layout';\n  var isApi = filename.match(/\\+api\\.(\\w+\\.)?[jt]sx?$/);\n  if (filenameWithoutExtensions.startsWith('(') && filenameWithoutExtensions.endsWith(')')) {\n    throw new Error(`Invalid route ./${key}. Routes cannot end with '(group)' syntax`);\n  }\n  if (!isApi && filename.startsWith('+') && filenameWithoutExtensions !== '+not-found') {\n    var renamedRoute = [].concat(_toConsumableArray(parts.slice(0, -1)), [filename.slice(1)]).join('/');\n    throw new Error(`Invalid route ./${key}. Route nodes cannot start with the '+' character. \"Please rename to ${renamedRoute}\"`);\n  }\n  var specificity = 0;\n  var hasPlatformExtension = validPlatforms.has(platformExtension);\n  var usePlatformRoutes = (_options$platformRout = options.platformRoutes) != null ? _options$platformRout : true;\n  if (hasPlatformExtension) {\n    if (!usePlatformRoutes) {\n      specificity = -1;\n    } else if (!options.platform) {\n      specificity = -1;\n    } else if (platformExtension === options.platform) {\n      specificity = 2;\n    } else if (platformExtension === 'native' && options.platform !== 'web') {\n      specificity = 1;\n    } else if (platformExtension !== options.platform) {\n      specificity = -1;\n    }\n    if (isApi && specificity !== 0) {\n      throw new Error(`Api routes cannot have platform extensions. Please remove '.${platformExtension}' from './${key}'`);\n    }\n    route = route.replace(new RegExp(`.${platformExtension}$`), '');\n  }\n  return {\n    route: route,\n    specificity: specificity,\n    isLayout: isLayout,\n    isApi: isApi\n  };\n}\nfunction getIgnoreList(options) {\n  var _options$ignore;\n  var ignore = [/^\\.\\/\\+html\\.[tj]sx?$/].concat(_toConsumableArray((_options$ignore = options == null ? void 0 : options.ignore) != null ? _options$ignore : []));\n  if ((options == null ? void 0 : options.preserveApiRoutes) !== true) {\n    ignore.push(/\\+api\\.[tj]sx?$/);\n  }\n  return ignore;\n}\nexports.getIgnoreList = getIgnoreList;\nfunction extrapolateGroups(key) {\n  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n  var match = (0, matchers_1.matchArrayGroupName)(key);\n  if (!match) {\n    keys.add(key);\n    return keys;\n  }\n  var groups = match.split(',');\n  var groupsSet = new Set(groups);\n  if (groupsSet.size !== groups.length) {\n    throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${key}\".`);\n  }\n  if (groups.length === 1) {\n    keys.add(key);\n    return keys;\n  }\n  for (var group of groups) {\n    extrapolateGroups(key.replace(match, group.trim()), keys);\n  }\n  return keys;\n}\nexports.extrapolateGroups = extrapolateGroups;\nfunction generateDynamic(path) {\n  var dynamic = path.split('/').map(function (part) {\n    if (part === '+not-found') {\n      return {\n        name: '+not-found',\n        deep: true,\n        notFound: true\n      };\n    }\n    var deepDynamicName = (0, matchers_1.matchDeepDynamicRouteName)(part);\n    var dynamicName = deepDynamicName != null ? deepDynamicName : (0, matchers_1.matchDynamicName)(part);\n    if (!dynamicName) return null;\n    return {\n      name: dynamicName,\n      deep: !!deepDynamicName\n    };\n  }).filter(function (part) {\n    return !!part;\n  });\n  return dynamic.length === 0 ? null : dynamic;\n}\nexports.generateDynamic = generateDynamic;\nfunction appendSitemapRoute(directory, options) {\n  if (!directory.files.has('_sitemap') && options.getSystemRoute) {\n    directory.files.set('_sitemap', [options.getSystemRoute({\n      type: 'route',\n      route: '_sitemap'\n    })]);\n  }\n}\nfunction appendNotFoundRoute(directory, options) {\n  if (!directory.files.has('+not-found') && options.getSystemRoute) {\n    directory.files.set('+not-found', [options.getSystemRoute({\n      type: 'route',\n      route: '+not-found'\n    })]);\n  }\n}\nfunction getLayoutNode(node, options) {\n  var groupName = (0, matchers_1.matchLastGroupName)(node.route);\n  var childMatchingGroup = node.children.find(function (child) {\n    return child.route.replace(/\\/index$/, '') === groupName;\n  });\n  var initialRouteName = childMatchingGroup == null ? void 0 : childMatchingGroup.route;\n  var loaded = node.loadRoute();\n  if (loaded != null && loaded.unstable_settings) {\n    try {\n      var _loaded$unstable_sett;\n      initialRouteName = (_loaded$unstable_sett = loaded.unstable_settings.initialRouteName) != null ? _loaded$unstable_sett : initialRouteName;\n    } catch (error) {\n      if (error instanceof Error) {\n        if (!error.message.match(/You cannot dot into a client module/)) {\n          throw error;\n        }\n      }\n    }\n    if (groupName) {\n      var _loaded$unstable_sett2, _loaded$unstable_sett3;\n      var groupSpecificInitialRouteName = (_loaded$unstable_sett2 = loaded.unstable_settings) == null ? void 0 : (_loaded$unstable_sett3 = _loaded$unstable_sett2[groupName]) == null ? void 0 : _loaded$unstable_sett3.initialRouteName;\n      initialRouteName = groupSpecificInitialRouteName != null ? groupSpecificInitialRouteName : initialRouteName;\n    }\n  }\n  return _objectSpread(_objectSpread({}, node), {}, {\n    route: node.route.replace(/\\/?_layout$/, ''),\n    children: [],\n    initialRouteName: initialRouteName\n  });\n}\nfunction crawlAndAppendInitialRoutesAndEntryFiles(node, options) {\n  var entryPoints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (node.type === 'route') {\n    node.entryPoints = _toConsumableArray(new Set([].concat(_toConsumableArray(entryPoints), [node.contextKey])));\n  } else if (node.type === 'layout') {\n    if (!node.children) {\n      throw new Error(`Layout \"${node.contextKey}\" does not contain any child routes`);\n    }\n    entryPoints = [].concat(_toConsumableArray(entryPoints), [node.contextKey]);\n    var groupName = (0, matchers_1.matchGroupName)(node.route);\n    var childMatchingGroup = node.children.find(function (child) {\n      return child.route.replace(/\\/index$/, '') === groupName;\n    });\n    var initialRouteName = childMatchingGroup == null ? void 0 : childMatchingGroup.route;\n    if (!options.internal_stripLoadRoute) {\n      var loaded = node.loadRoute();\n      if (loaded != null && loaded.unstable_settings) {\n        try {\n          var _loaded$unstable_sett4;\n          initialRouteName = (_loaded$unstable_sett4 = loaded.unstable_settings.initialRouteName) != null ? _loaded$unstable_sett4 : initialRouteName;\n        } catch (error) {\n          if (error instanceof Error) {\n            if (!error.message.match(/You cannot dot into a client module/)) {\n              throw error;\n            }\n          }\n        }\n        if (groupName) {\n          var _loaded$unstable_sett5, _loaded$unstable_sett6;\n          var groupSpecificInitialRouteName = (_loaded$unstable_sett5 = loaded.unstable_settings) == null ? void 0 : (_loaded$unstable_sett6 = _loaded$unstable_sett5[groupName]) == null ? void 0 : _loaded$unstable_sett6.initialRouteName;\n          initialRouteName = groupSpecificInitialRouteName != null ? groupSpecificInitialRouteName : initialRouteName;\n        }\n      }\n    }\n    if (initialRouteName) {\n      var initialRoute = node.children.find(function (child) {\n        return child.route === initialRouteName;\n      });\n      if (!initialRoute) {\n        var validInitialRoutes = node.children.filter(function (child) {\n          return !child.generated;\n        }).map(function (child) {\n          return `'${child.route}'`;\n        }).join(', ');\n        if (groupName) {\n          throw new Error(`Layout ${node.contextKey} has invalid initialRouteName '${initialRouteName}' for group '(${groupName})'. Valid options are: ${validInitialRoutes}`);\n        } else {\n          throw new Error(`Layout ${node.contextKey} has invalid initialRouteName '${initialRouteName}'. Valid options are: ${validInitialRoutes}`);\n        }\n      }\n      node.initialRouteName = initialRouteName;\n      entryPoints.push(initialRoute.contextKey);\n    }\n    for (var child of node.children) {\n      crawlAndAppendInitialRoutesAndEntryFiles(child, options, entryPoints);\n    }\n  }\n}\nfunction getMostSpecific(routes) {\n  var route = routes[routes.length - 1];\n  if (!routes[0]) {\n    throw new Error(`The file ${route.contextKey} does not have a fallback sibling file without a platform extension.`);\n  }\n  return routes[routes.length - 1];\n}","map":{"version":3,"names":["matchers_1","require","validPlatforms","Set","getRoutes","contextModule","options","directoryTree","getDirectoryTree","rootNode","flattenDirectoryTreeToRoutes","ignoreEntryPoints","crawlAndAppendInitialRoutesAndEntryFiles","exports","importMode","process","env","EXPO_ROUTER_IMPORT_MODE","ignoreList","ignore","push","apply","_toConsumableArray","preserveApiRoutes","rootDirectory","files","Map","subdirectories","hasRoutes","isValid","_loop","filePath","some","regex","test","meta","getFileMeta","specificity","node","type","isApi","isLayout","loadRoute","routeModule","ignoreRequireErrors","_unused","NODE_ENV","_routeModule","Promise","Error","defaultExport","default","Function","constructor","name","contextKey","route","dynamic","children","routeItem","console","warn","includes","extrapolateGroups","subdirectoryParts","split","slice","directory","part","subDirectory","get","set","_objectSpread","layout","existing","getLayoutNode","fileKey","nodes","_ret","keys","getSystemRoute","skipGenerated","sitemap","appendSitemapRoute","notFound","appendNotFoundRoute","pathToRemove","arguments","length","undefined","previousLayout","getMostSpecific","internal_stripLoadRoute","newRoute","replace","generateDynamic","routes","values","routeNode","child","key","_options$platformRout","parts","removeSupportedExtensions","filename","_split","_split2","_slicedToArray","filenameWithoutExtensions","platformExtension","match","startsWith","endsWith","renamedRoute","concat","join","hasPlatformExtension","has","usePlatformRoutes","platformRoutes","platform","RegExp","getIgnoreList","_options$ignore","matchArrayGroupName","add","groups","groupsSet","size","group","trim","path","map","deep","deepDynamicName","matchDeepDynamicRouteName","dynamicName","matchDynamicName","filter","groupName","matchLastGroupName","childMatchingGroup","find","initialRouteName","loaded","unstable_settings","_loaded$unstable_sett","error","message","_loaded$unstable_sett2","_loaded$unstable_sett3","groupSpecificInitialRouteName","entryPoints","matchGroupName","_loaded$unstable_sett4","_loaded$unstable_sett5","_loaded$unstable_sett6","initialRoute","validInitialRoutes","generated"],"sources":["C:\\Users\\R User\\Documents\\software_dev\\BranchBuddy\\node_modules\\expo-router\\src\\getRoutesCore.ts"],"sourcesContent":["import type { DynamicConvention, RouteNode } from './Route';\nimport {\n  matchArrayGroupName,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  matchLastGroupName,\n  removeSupportedExtensions,\n} from './matchers';\nimport type { RequireContext } from './types';\n\nexport type Options = {\n  ignore?: RegExp[];\n  preserveApiRoutes?: boolean;\n  ignoreRequireErrors?: boolean;\n  ignoreEntryPoints?: boolean;\n  /* Used to simplify testing for toEqual() comparison */\n  internal_stripLoadRoute?: boolean;\n  /* Used to simplify by skipping the generated routes */\n  skipGenerated?: boolean;\n  /* Skip the generated not found route  */\n  notFound?: boolean;\n  importMode?: string;\n  platformRoutes?: boolean;\n  sitemap?: boolean;\n  platform?: string;\n\n  /** Get the system route for a location. Useful for shimming React Native imports in SSR environments. */\n  getSystemRoute: (route: Pick<RouteNode, 'route' | 'type'>) => RouteNode;\n};\n\ntype DirectoryNode = {\n  layout?: RouteNode[];\n  files: Map<string, RouteNode[]>;\n  subdirectories: Map<string, DirectoryNode>;\n};\n\nconst validPlatforms = new Set(['android', 'ios', 'native', 'web']);\n\n/**\n * Given a Metro context module, return an array of nested routes.\n *\n * This is a two step process:\n *  1. Convert the RequireContext keys (file paths) into a directory tree.\n *      - This should extrapolate array syntax into multiple routes\n *      - Routes are given a specificity score\n *  2. Flatten the directory tree into routes\n *      - Routes in directories without _layout files are hoisted to the nearest _layout\n *      - The name of the route is relative to the nearest _layout\n *      - If multiple routes have the same name, the most specific route is used\n */\nexport function getRoutes(contextModule: RequireContext, options: Options): RouteNode | null {\n  const directoryTree = getDirectoryTree(contextModule, options);\n\n  // If there are no routes\n  if (!directoryTree) {\n    return null;\n  }\n\n  const rootNode = flattenDirectoryTreeToRoutes(directoryTree, options);\n\n  if (!options.ignoreEntryPoints) {\n    crawlAndAppendInitialRoutesAndEntryFiles(rootNode, options);\n  }\n\n  return rootNode;\n}\n\n/**\n * Converts the RequireContext keys (file paths) into a directory tree.\n */\nfunction getDirectoryTree(contextModule: RequireContext, options: Options) {\n  const importMode = options.importMode || process.env.EXPO_ROUTER_IMPORT_MODE;\n\n  const ignoreList: RegExp[] = [/^\\.\\/\\+(html|native-intent)\\.[tj]sx?$/]; // Ignore the top level ./+html file\n\n  if (options.ignore) {\n    ignoreList.push(...options.ignore);\n  }\n  if (!options.preserveApiRoutes) {\n    ignoreList.push(/\\+api\\.[tj]sx?$/);\n  }\n\n  const rootDirectory: DirectoryNode = {\n    files: new Map(),\n    subdirectories: new Map(),\n  };\n\n  let hasRoutes = false;\n  let isValid = false;\n\n  for (const filePath of contextModule.keys()) {\n    if (ignoreList.some((regex) => regex.test(filePath))) {\n      continue;\n    }\n\n    isValid = true;\n\n    const meta = getFileMeta(filePath, options);\n\n    // This is a file that should be ignored. e.g maybe it has an invalid platform?\n    if (meta.specificity < 0) {\n      continue;\n    }\n\n    let node: RouteNode = {\n      type: meta.isApi ? 'api' : meta.isLayout ? 'layout' : 'route',\n      loadRoute() {\n        let routeModule: any;\n        if (options.ignoreRequireErrors) {\n          try {\n            routeModule = contextModule(filePath);\n          } catch {\n            routeModule = {};\n          }\n        } else {\n          routeModule = contextModule(filePath);\n        }\n\n        if (process.env.NODE_ENV === 'development' && importMode === 'sync') {\n          // In development mode, when async routes are disabled, add some extra error handling to improve the developer experience.\n          // This can be useful when you accidentally use an async function in a route file for the default export.\n          if (routeModule instanceof Promise) {\n            throw new Error(\n              `Route \"${filePath}\" cannot be a promise when async routes is disabled.`\n            );\n          }\n\n          const defaultExport = routeModule?.default;\n          if (defaultExport instanceof Promise) {\n            throw new Error(\n              `The default export from route \"${filePath}\" is a promise. Ensure the React Component does not use async or promises.`\n            );\n          }\n\n          // check if default is an async function without invoking it\n          if (\n            defaultExport instanceof Function &&\n            // This only works on web because Hermes support async functions so we have to transform them out.\n            defaultExport.constructor.name === 'AsyncFunction'\n          ) {\n            throw new Error(\n              `The default export from route \"${filePath}\" is an async function. Ensure the React Component does not use async or promises.`\n            );\n          }\n        }\n\n        return routeModule;\n      },\n      contextKey: filePath,\n      route: '', // This is overwritten during hoisting based upon the _layout\n      dynamic: null,\n      children: [], // While we are building the directory tree, we don't know the node's children just yet. This is added during hoisting\n    };\n\n    if (process.env.NODE_ENV === 'development') {\n      // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should\n      // filter the missing routes.\n      if (node.type !== 'api' && importMode === 'sync') {\n        const routeItem = node.loadRoute();\n        // Have a warning for nullish ex\n        const route = routeItem?.default;\n        if (route == null) {\n          // Do not throw an error since a user may just be creating a new route.\n          console.warn(\n            `Route \"${filePath}\" is missing the required default export. Ensure a React component is exported as default.`\n          );\n          continue;\n        }\n        if (['boolean', 'number', 'string'].includes(typeof route)) {\n          throw new Error(\n            `The default export from route \"${filePath}\" is an unsupported type: \"${typeof route}\". Only React Components are supported as default exports from route files.`\n          );\n        }\n      }\n    }\n\n    /**\n     * A single filepath may be extrapolated into multiple routes if it contains array syntax.\n     * Another way to thinking about is that a filepath node is present in multiple leaves of the directory tree.\n     */\n    for (const route of extrapolateGroups(meta.route)) {\n      // Traverse the directory tree to its leaf node, creating any missing directories along the way\n      const subdirectoryParts = route.split('/').slice(0, -1);\n\n      // Start at the root directory and traverse the path to the leaf directory\n      let directory = rootDirectory;\n\n      for (const part of subdirectoryParts) {\n        let subDirectory = directory.subdirectories.get(part);\n\n        // Create any missing subdirectories\n        if (!subDirectory) {\n          subDirectory = {\n            files: new Map(),\n            subdirectories: new Map(),\n          };\n          directory.subdirectories.set(part, subDirectory);\n        }\n\n        directory = subDirectory;\n      }\n\n      // Clone the node for this route\n      node = { ...node, route };\n\n      if (meta.isLayout) {\n        directory.layout ??= [];\n        const existing = directory.layout[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The layouts \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          node = getLayoutNode(node, options);\n          directory.layout[meta.specificity] = node;\n        }\n      } else if (meta.isApi) {\n        const fileKey = `${route}+api`;\n        let nodes = directory.files.get(fileKey);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(fileKey, nodes);\n        }\n\n        // API Routes have no specificity, they are always the first node\n        const existing = nodes[0];\n\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The API route file \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          nodes[0] = node;\n        }\n      } else {\n        let nodes = directory.files.get(route);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(route, nodes);\n        }\n\n        /**\n         * If there is an existing node with the same specificity, then we have a conflict.\n         * NOTE(Platform Routes):\n         *    We cannot check for specificity conflicts here, as we haven't processed all the context keys yet!\n         *    This will be checked during hoisting, as well as enforcing that all routes have a non-platform route.\n         */\n        const existing = nodes[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The route files \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          hasRoutes ||= true;\n          nodes[meta.specificity] = node;\n        }\n      }\n    }\n  }\n\n  // If there are no routes/layouts then we should display the tutorial.\n  if (!isValid) {\n    return null;\n  }\n\n  /**\n   * If there are no top-level _layout, add a default _layout\n   * While this is a generated route, it will still be generated even if skipGenerated is true.\n   */\n  if (!rootDirectory.layout) {\n    rootDirectory.layout = [\n      options.getSystemRoute({\n        type: 'layout',\n        route: '',\n      }),\n    ];\n  }\n\n  // Only include the sitemap if there are routes.\n  if (!options.skipGenerated) {\n    if (hasRoutes && options.sitemap !== false) {\n      appendSitemapRoute(rootDirectory, options);\n    }\n    if (options.notFound !== false) {\n      appendNotFoundRoute(rootDirectory, options);\n    }\n  }\n  return rootDirectory;\n}\n\n/**\n * Flatten the directory tree into routes, hoisting routes to the nearest _layout.\n */\nfunction flattenDirectoryTreeToRoutes(\n  directory: DirectoryNode,\n  options: Options,\n  /* The nearest _layout file in the directory tree */\n  layout?: RouteNode,\n  /* Route names are relative to their layout */\n  pathToRemove = ''\n) {\n  /**\n   * This directory has a _layout file so it becomes the new target for hoisting routes.\n   */\n  if (directory.layout) {\n    const previousLayout = layout;\n    layout = getMostSpecific(directory.layout);\n\n    // Add the new layout as a child of its parent\n    if (previousLayout) {\n      previousLayout.children.push(layout);\n    }\n\n    if (options.internal_stripLoadRoute) {\n      delete (layout as any).loadRoute;\n    }\n\n    // `route` is the absolute pathname. We need to make this relative to the last _layout\n    const newRoute = layout.route.replace(pathToRemove, '');\n    pathToRemove = layout.route ? `${layout.route}/` : '';\n\n    // Now update this layout with the new relative route and dynamic conventions\n    layout.route = newRoute;\n    layout.dynamic = generateDynamic(layout.contextKey.slice(0));\n  }\n\n  // This should never occur as there will always be a root layout, but it makes the type system happy\n  if (!layout) throw new Error('Expo Router Internal Error: No nearest layout');\n\n  for (const routes of directory.files.values()) {\n    const routeNode = getMostSpecific(routes);\n\n    // `route` is the absolute pathname. We need to make this relative to the nearest layout\n    routeNode.route = routeNode.route.replace(pathToRemove, '');\n    routeNode.dynamic = generateDynamic(routeNode.route);\n\n    if (options.internal_stripLoadRoute) {\n      delete (routeNode as any).loadRoute;\n    }\n\n    layout.children.push(routeNode);\n  }\n\n  // Recursively flatten the subdirectories\n  for (const child of directory.subdirectories.values()) {\n    flattenDirectoryTreeToRoutes(child, options, layout, pathToRemove);\n  }\n\n  return layout;\n}\n\nfunction getFileMeta(key: string, options: Options) {\n  // Remove the leading `./`\n  key = key.replace(/^\\.\\//, '');\n\n  const parts = key.split('/');\n  let route = removeSupportedExtensions(key);\n  const filename = parts[parts.length - 1];\n  const [filenameWithoutExtensions, platformExtension] =\n    removeSupportedExtensions(filename).split('.');\n  const isLayout = filenameWithoutExtensions === '_layout';\n  const isApi = filename.match(/\\+api\\.(\\w+\\.)?[jt]sx?$/);\n\n  if (filenameWithoutExtensions.startsWith('(') && filenameWithoutExtensions.endsWith(')')) {\n    throw new Error(`Invalid route ./${key}. Routes cannot end with '(group)' syntax`);\n  }\n\n  // Nested routes cannot start with the '+' character, except for the '+not-found' route\n  if (!isApi && filename.startsWith('+') && filenameWithoutExtensions !== '+not-found') {\n    const renamedRoute = [...parts.slice(0, -1), filename.slice(1)].join('/');\n    throw new Error(\n      `Invalid route ./${key}. Route nodes cannot start with the '+' character. \"Please rename to ${renamedRoute}\"`\n    );\n  }\n  let specificity = 0;\n\n  const hasPlatformExtension = validPlatforms.has(platformExtension);\n  const usePlatformRoutes = options.platformRoutes ?? true;\n\n  if (hasPlatformExtension) {\n    if (!usePlatformRoutes) {\n      // If the user has disabled platform routes, then we should ignore this file\n      specificity = -1;\n    } else if (!options.platform) {\n      // If we don't have a platform, then we should ignore this file\n      // This used by typed routes, sitemap, etc\n      specificity = -1;\n    } else if (platformExtension === options.platform) {\n      // If the platform extension is the same as the options.platform, then it is the most specific\n      specificity = 2;\n    } else if (platformExtension === 'native' && options.platform !== 'web') {\n      // `native` is allow but isn't as specific as the platform\n      specificity = 1;\n    } else if (platformExtension !== options.platform) {\n      // Somehow we have a platform extension that doesn't match the options.platform and it isn't native\n      // This is an invalid file and we will ignore it\n      specificity = -1;\n    }\n\n    if (isApi && specificity !== 0) {\n      throw new Error(\n        `Api routes cannot have platform extensions. Please remove '.${platformExtension}' from './${key}'`\n      );\n    }\n\n    route = route.replace(new RegExp(`.${platformExtension}$`), '');\n  }\n\n  return {\n    route,\n    specificity,\n    isLayout,\n    isApi,\n  };\n}\n\nexport function getIgnoreList(options?: Options) {\n  const ignore: RegExp[] = [/^\\.\\/\\+html\\.[tj]sx?$/, ...(options?.ignore ?? [])];\n  if (options?.preserveApiRoutes !== true) {\n    ignore.push(/\\+api\\.[tj]sx?$/);\n  }\n  return ignore;\n}\n\n/**\n * Generates a set of strings which have the router array syntax extrapolated.\n *\n * /(a,b)/(c,d)/e.tsx => new Set(['a/c/e.tsx', 'a/d/e.tsx', 'b/c/e.tsx', 'b/d/e.tsx'])\n */\nexport function extrapolateGroups(key: string, keys: Set<string> = new Set()): Set<string> {\n  const match = matchArrayGroupName(key);\n\n  if (!match) {\n    keys.add(key);\n    return keys;\n  }\n  const groups = match.split(',');\n  const groupsSet = new Set(groups);\n\n  if (groupsSet.size !== groups.length) {\n    throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${key}\".`);\n  }\n\n  if (groups.length === 1) {\n    keys.add(key);\n    return keys;\n  }\n\n  for (const group of groups) {\n    extrapolateGroups(key.replace(match, group.trim()), keys);\n  }\n\n  return keys;\n}\n\nexport function generateDynamic(path: string): DynamicConvention[] | null {\n  const dynamic = path\n    .split('/')\n    .map((part): DynamicConvention | null => {\n      if (part === '+not-found') {\n        return {\n          name: '+not-found',\n          deep: true,\n          notFound: true,\n        };\n      }\n\n      const deepDynamicName = matchDeepDynamicRouteName(part);\n      const dynamicName = deepDynamicName ?? matchDynamicName(part);\n\n      if (!dynamicName) return null;\n      return { name: dynamicName, deep: !!deepDynamicName };\n    })\n    .filter((part): part is DynamicConvention => !!part);\n\n  return dynamic.length === 0 ? null : dynamic;\n}\n\nfunction appendSitemapRoute(directory: DirectoryNode, options: Options) {\n  if (!directory.files.has('_sitemap') && options.getSystemRoute) {\n    directory.files.set('_sitemap', [\n      options.getSystemRoute({\n        type: 'route',\n        route: '_sitemap',\n      }),\n    ]);\n  }\n}\n\nfunction appendNotFoundRoute(directory: DirectoryNode, options: Options) {\n  if (!directory.files.has('+not-found') && options.getSystemRoute) {\n    directory.files.set('+not-found', [\n      options.getSystemRoute({\n        type: 'route',\n        route: '+not-found',\n      }),\n    ]);\n  }\n}\n\nfunction getLayoutNode(node: RouteNode, options: Options) {\n  /**\n   * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.\n   * Each of these layouts will have a different initialRouteName based upon the first group name.\n   */\n  // We may strip loadRoute during testing\n  const groupName = matchLastGroupName(node.route);\n  const childMatchingGroup = node.children.find((child) => {\n    return child.route.replace(/\\/index$/, '') === groupName;\n  });\n  let initialRouteName = childMatchingGroup?.route;\n  const loaded = node.loadRoute();\n  if (loaded?.unstable_settings) {\n    try {\n      // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n      initialRouteName = loaded.unstable_settings.initialRouteName ?? initialRouteName;\n    } catch (error: any) {\n      if (error instanceof Error) {\n        if (!error.message.match(/You cannot dot into a client module/)) {\n          throw error;\n        }\n      }\n    }\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n    }\n  }\n\n  return {\n    ...node,\n    route: node.route.replace(/\\/?_layout$/, ''),\n    children: [], // Each layout should have its own children\n    initialRouteName,\n  };\n}\n\nfunction crawlAndAppendInitialRoutesAndEntryFiles(\n  node: RouteNode,\n  options: Options,\n  entryPoints: string[] = []\n) {\n  if (node.type === 'route') {\n    node.entryPoints = [...new Set([...entryPoints, node.contextKey])];\n  } else if (node.type === 'layout') {\n    if (!node.children) {\n      throw new Error(`Layout \"${node.contextKey}\" does not contain any child routes`);\n    }\n\n    // Every node below this layout will have it as an entryPoint\n    entryPoints = [...entryPoints, node.contextKey];\n\n    /**\n     * Calculate the initialRouteNode\n     *\n     * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.\n     * Each of these layouts will have a different initialRouteName based upon the first group.\n     */\n    const groupName = matchGroupName(node.route);\n    const childMatchingGroup = node.children.find((child) => {\n      return child.route.replace(/\\/index$/, '') === groupName;\n    });\n    let initialRouteName = childMatchingGroup?.route;\n    // We may strip loadRoute during testing\n    if (!options.internal_stripLoadRoute) {\n      const loaded = node.loadRoute();\n      if (loaded?.unstable_settings) {\n        try {\n          // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n          initialRouteName = loaded.unstable_settings.initialRouteName ?? initialRouteName;\n        } catch (error: any) {\n          if (error instanceof Error) {\n            if (!error.message.match(/You cannot dot into a client module/)) {\n              throw error;\n            }\n          }\n        }\n\n        if (groupName) {\n          // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n          const groupSpecificInitialRouteName =\n            loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n          initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n        }\n      }\n    }\n\n    if (initialRouteName) {\n      const initialRoute = node.children.find((child) => child.route === initialRouteName);\n      if (!initialRoute) {\n        const validInitialRoutes = node.children\n          .filter((child) => !child.generated)\n          .map((child) => `'${child.route}'`)\n          .join(', ');\n\n        if (groupName) {\n          throw new Error(\n            `Layout ${node.contextKey} has invalid initialRouteName '${initialRouteName}' for group '(${groupName})'. Valid options are: ${validInitialRoutes}`\n          );\n        } else {\n          throw new Error(\n            `Layout ${node.contextKey} has invalid initialRouteName '${initialRouteName}'. Valid options are: ${validInitialRoutes}`\n          );\n        }\n      }\n\n      // Navigators can add initialsRoutes into the history, so they need to be to be included in the entryPoints\n      node.initialRouteName = initialRouteName;\n      entryPoints.push(initialRoute.contextKey);\n    }\n\n    for (const child of node.children) {\n      crawlAndAppendInitialRoutesAndEntryFiles(child, options, entryPoints);\n    }\n  }\n}\n\nfunction getMostSpecific(routes: RouteNode[]) {\n  const route = routes[routes.length - 1];\n\n  if (!routes[0]) {\n    throw new Error(\n      `The file ${route.contextKey} does not have a fallback sibling file without a platform extension.`\n    );\n  }\n\n  // This works even tho routes is holey array (e.g it might have index 0 and 2 but not 1)\n  // `.length` includes the holes in its count\n  return routes[routes.length - 1];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}