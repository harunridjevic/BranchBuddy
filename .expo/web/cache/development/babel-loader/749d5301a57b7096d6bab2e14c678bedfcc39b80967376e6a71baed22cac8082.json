{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getStateFromPath = getStateFromPath;\nvar _escapeStringRegexp = _interopRequireDefault(require(\"escape-string-regexp\"));\nvar queryString = _interopRequireWildcard(require(\"query-string\"));\nvar _arrayStartsWith = require(\"./arrayStartsWith.js\");\nvar _findFocusedRoute = require(\"./findFocusedRoute.js\");\nvar _getPatternParts = require(\"./getPatternParts.js\");\nvar _isArrayEqual = require(\"./isArrayEqual.js\");\nvar _validatePathConfig = require(\"./validatePathConfig.js\");\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n    t = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n    return e ? t : r;\n  })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n  var t = _getRequireWildcardCache(r);\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n      __proto__: null\n    },\n    a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n  return n.default = e, t && t.set(e, n), n;\n}\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    default: e\n  };\n}\nfunction getStateFromPath(path, options) {\n  var _options$path;\n  var _getConfigResources = getConfigResources(options),\n    initialRoutes = _getConfigResources.initialRoutes,\n    configs = _getConfigResources.configs;\n  var screens = options == null ? void 0 : options.screens;\n  var remaining = path.replace(/\\/+/g, '/').replace(/^\\//, '').replace(/\\?.*$/, '');\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n  var prefix = options == null ? void 0 : (_options$path = options.path) == null ? void 0 : _options$path.replace(/^\\//, '');\n  if (prefix) {\n    var normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;\n    if (!remaining.startsWith(normalizedPrefix)) {\n      return undefined;\n    }\n    remaining = remaining.replace(normalizedPrefix, '');\n  }\n  if (screens === undefined) {\n    var _routes = remaining.split('/').filter(Boolean).map(function (segment) {\n      var name = decodeURIComponent(segment);\n      return {\n        name: name\n      };\n    });\n    if (_routes.length) {\n      return createNestedStateObject(path, _routes, initialRoutes);\n    }\n    return undefined;\n  }\n  if (remaining === '/') {\n    var match = configs.find(function (config) {\n      return config.segments.join('/') === '';\n    });\n    if (match) {\n      return createNestedStateObject(path, match.routeNames.map(function (name) {\n        return {\n          name: name\n        };\n      }), initialRoutes, configs);\n    }\n    return undefined;\n  }\n  var result;\n  var current;\n  var _matchAgainstConfigs = matchAgainstConfigs(remaining, configs),\n    routes = _matchAgainstConfigs.routes,\n    remainingPath = _matchAgainstConfigs.remainingPath;\n  if (routes !== undefined) {\n    current = createNestedStateObject(path, routes, initialRoutes, configs);\n    remaining = remainingPath;\n    result = current;\n  }\n  if (current == null || result == null) {\n    return undefined;\n  }\n  return result;\n}\nvar cachedConfigResources = new WeakMap();\nfunction getConfigResources(options) {\n  if (!options) return prepareConfigResources();\n  var cached = cachedConfigResources.get(options);\n  if (cached) return cached;\n  var resources = prepareConfigResources(options);\n  cachedConfigResources.set(options, resources);\n  return resources;\n}\nfunction prepareConfigResources(options) {\n  if (options) {\n    (0, _validatePathConfig.validatePathConfig)(options);\n  }\n  var initialRoutes = getInitialRoutes(options);\n  var configs = getSortedNormalizedConfigs(initialRoutes, options == null ? void 0 : options.screens);\n  checkForDuplicatedConfigs(configs);\n  var configWithRegexes = getConfigsWithRegexes(configs);\n  return {\n    initialRoutes: initialRoutes,\n    configs: configs,\n    configWithRegexes: configWithRegexes\n  };\n}\nfunction getInitialRoutes(options) {\n  var initialRoutes = [];\n  if (options != null && options.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: []\n    });\n  }\n  return initialRoutes;\n}\nfunction getSortedNormalizedConfigs(initialRoutes) {\n  var _ref;\n  var screens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(Object.keys(screens).map(function (key) {\n    return _createNormalizedConfigs(key, screens, initialRoutes, [], [], []);\n  }))).sort(function (a, b) {\n    if ((0, _isArrayEqual.isArrayEqual)(a.segments, b.segments)) {\n      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n    }\n    if ((0, _arrayStartsWith.arrayStartsWith)(a.segments, b.segments)) {\n      return -1;\n    }\n    if ((0, _arrayStartsWith.arrayStartsWith)(b.segments, a.segments)) {\n      return 1;\n    }\n    for (var i = 0; i < Math.max(a.segments.length, b.segments.length); i++) {\n      if (a.segments[i] == null) {\n        return 1;\n      }\n      if (b.segments[i] == null) {\n        return -1;\n      }\n      var aWildCard = a.segments[i] === '*';\n      var bWildCard = b.segments[i] === '*';\n      var aParam = a.segments[i].startsWith(':');\n      var bParam = b.segments[i].startsWith(':');\n      var aRegex = aParam && a.segments[i].includes('(');\n      var bRegex = bParam && b.segments[i].includes('(');\n      if (aWildCard && bWildCard || aRegex && bRegex) {\n        continue;\n      }\n      if (aWildCard && !bWildCard) {\n        return 1;\n      }\n      if (bWildCard && !aWildCard) {\n        return -1;\n      }\n      if (aParam && !bParam) {\n        return 1;\n      }\n      if (bParam && !aParam) {\n        return -1;\n      }\n      if (aRegex && !bRegex) {\n        return -1;\n      }\n      if (bRegex && !aRegex) {\n        return 1;\n      }\n    }\n    return a.segments.length - b.segments.length;\n  });\n}\nfunction checkForDuplicatedConfigs(configs) {\n  configs.reduce(function (acc, config) {\n    var pattern = config.segments.join('/');\n    if (acc[pattern]) {\n      var a = acc[pattern].routeNames;\n      var b = config.routeNames;\n      var intersects = a.length > b.length ? b.every(function (it, i) {\n        return a[i] === it;\n      }) : a.every(function (it, i) {\n        return b[i] === it;\n      });\n      if (!intersects) {\n        throw new Error(`Found conflicting screens with the same pattern. The pattern '${pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);\n      }\n    }\n    return Object.assign(acc, _defineProperty({}, pattern, config));\n  }, {});\n}\nfunction getConfigsWithRegexes(configs) {\n  return configs.map(function (c) {\n    return _objectSpread(_objectSpread({}, c), {}, {\n      regex: c.regex ? new RegExp(c.regex.source + '$') : undefined\n    });\n  });\n}\nvar matchAgainstConfigs = function matchAgainstConfigs(remaining, configs) {\n  var routes;\n  var remainingPath = remaining;\n  var _loop = function _loop(config) {\n      if (!config.regex) {\n        return 0;\n      }\n      var match = remainingPath.match(config.regex);\n      if (match) {\n        routes = config.routeNames.map(function (routeName) {\n          var routeConfig = configs.find(function (c) {\n            return c.screen === routeName && (0, _arrayStartsWith.arrayStartsWith)(config.segments, c.segments);\n          });\n          var params = routeConfig && match.groups ? Object.fromEntries(Object.entries(match.groups).map(function (_ref2) {\n            var _ref3 = _slicedToArray(_ref2, 2),\n              key = _ref3[0],\n              value = _ref3[1];\n            var index = Number(key.replace('param_', ''));\n            var param = routeConfig.params.find(function (it) {\n              return it.index === index;\n            });\n            if ((param == null ? void 0 : param.screen) === routeName && param != null && param.name) {\n              return [param.name, value];\n            }\n            return null;\n          }).filter(function (it) {\n            return it != null;\n          }).map(function (_ref4) {\n            var _routeConfig$parse;\n            var _ref5 = _slicedToArray(_ref4, 2),\n              key = _ref5[0],\n              value = _ref5[1];\n            if (value == null) {\n              return [key, undefined];\n            }\n            var decoded = decodeURIComponent(value);\n            var parsed = (_routeConfig$parse = routeConfig.parse) != null && _routeConfig$parse[key] ? routeConfig.parse[key](decoded) : decoded;\n            return [key, parsed];\n          })) : undefined;\n          if (params && Object.keys(params).length) {\n            return {\n              name: routeName,\n              params: params\n            };\n          }\n          return {\n            name: routeName\n          };\n        });\n        remainingPath = remainingPath.replace(match[0], '');\n        return 1;\n      }\n    },\n    _ret;\n  for (var config of configs) {\n    _ret = _loop(config);\n    if (_ret === 0) continue;\n    if (_ret === 1) break;\n  }\n  return {\n    routes: routes,\n    remainingPath: remainingPath\n  };\n};\nvar _createNormalizedConfigs = function createNormalizedConfigs(screen, routeConfig, initials, paths, parentScreens, routeNames) {\n  var configs = [];\n  routeNames.push(screen);\n  parentScreens.push(screen);\n  var config = routeConfig[screen];\n  if (typeof config === 'string') {\n    paths.push({\n      screen: screen,\n      path: config\n    });\n    configs.push(createConfigItem(screen, _toConsumableArray(routeNames), _toConsumableArray(paths)));\n  } else if (typeof config === 'object') {\n    var _config$alias;\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path == null) {\n        throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \\`path: ''\\`.`);\n      }\n      var aliasConfigs = [];\n      if (config.alias) {\n        for (var alias of config.alias) {\n          if (typeof alias === 'string') {\n            aliasConfigs.push(createConfigItem(screen, _toConsumableArray(routeNames), [].concat(_toConsumableArray(paths), [{\n              screen: screen,\n              path: alias\n            }]), config.parse));\n          } else if (typeof alias === 'object') {\n            aliasConfigs.push(createConfigItem(screen, _toConsumableArray(routeNames), alias.exact ? [{\n              screen: screen,\n              path: alias.path\n            }] : [].concat(_toConsumableArray(paths), [{\n              screen: screen,\n              path: alias.path\n            }]), alias.parse));\n          }\n        }\n      }\n      if (config.exact) {\n        paths.length = 0;\n      }\n      paths.push({\n        screen: screen,\n        path: config.path\n      });\n      configs.push(createConfigItem(screen, _toConsumableArray(routeNames), _toConsumableArray(paths), config.parse));\n      configs.push.apply(configs, aliasConfigs);\n    }\n    if (typeof config !== 'string' && typeof config.path !== 'string' && (_config$alias = config.alias) != null && _config$alias.length) {\n      throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`);\n    }\n    if (config.screens) {\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens: parentScreens\n        });\n      }\n      Object.keys(config.screens).forEach(function (nestedConfig) {\n        var result = _createNormalizedConfigs(nestedConfig, config.screens, initials, _toConsumableArray(paths), _toConsumableArray(parentScreens), routeNames);\n        configs.push.apply(configs, _toConsumableArray(result));\n      });\n    }\n  }\n  routeNames.pop();\n  return configs;\n};\nvar createConfigItem = function createConfigItem(screen, routeNames, paths, parse) {\n  var parts = [];\n  var _loop2 = function _loop2(_screen) {\n    parts.push.apply(parts, _toConsumableArray((0, _getPatternParts.getPatternParts)(path).map(function (part) {\n      return _objectSpread(_objectSpread({}, part), {}, {\n        screen: _screen\n      });\n    })));\n  };\n  for (var _ref6 of paths) {\n    var _screen = _ref6.screen;\n    var path = _ref6.path;\n    _loop2(_screen);\n  }\n  var regex = parts.length ? new RegExp(`^(${parts.map(function (it, i) {\n    if (it.param) {\n      var reg = it.regex || '[^/]+';\n      return `(((?<param_${i}>${reg})\\\\/)${it.optional ? '?' : ''})`;\n    }\n    return `${it.segment === '*' ? '.*' : (0, _escapeStringRegexp.default)(it.segment)}\\\\/`;\n  }).join('')})$`) : undefined;\n  var segments = parts.map(function (it) {\n    return it.segment;\n  });\n  var params = parts.map(function (it, i) {\n    return it.param ? {\n      index: i,\n      screen: it.screen,\n      name: it.param\n    } : null;\n  }).filter(function (it) {\n    return it != null;\n  });\n  return {\n    screen: screen,\n    regex: regex,\n    segments: segments,\n    params: params,\n    routeNames: routeNames,\n    parse: parse\n  };\n};\nvar findParseConfigForRoute = function findParseConfigForRoute(routeName, flatConfig) {\n  for (var config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n};\nvar findInitialRoute = function findInitialRoute(routeName, parentScreens, initialRoutes) {\n  for (var config of initialRoutes) {\n    if (parentScreens.length === config.parentScreens.length) {\n      var sameParents = true;\n      for (var i = 0; i < parentScreens.length; i++) {\n        if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\n          sameParents = false;\n          break;\n        }\n      }\n      if (sameParents) {\n        return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n      }\n    }\n  }\n  return undefined;\n};\nvar createStateObject = function createStateObject(initialRoute, route, isEmpty) {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, route]\n      };\n    } else {\n      return {\n        routes: [route]\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{\n          name: initialRoute\n        }, _objectSpread(_objectSpread({}, route), {}, {\n          state: {\n            routes: []\n          }\n        })]\n      };\n    } else {\n      return {\n        routes: [_objectSpread(_objectSpread({}, route), {}, {\n          state: {\n            routes: []\n          }\n        })]\n      };\n    }\n  }\n};\nvar createNestedStateObject = function createNestedStateObject(path, routes, initialRoutes, flatConfig) {\n  var route = routes.shift();\n  var parentScreens = [];\n  var initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n  parentScreens.push(route.name);\n  var state = createStateObject(initialRoute, route, routes.length === 0);\n  if (routes.length > 0) {\n    var nestedState = state;\n    while (route = routes.shift()) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n      var nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n      nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state;\n      }\n      parentScreens.push(route.name);\n    }\n  }\n  route = (0, _findFocusedRoute.findFocusedRoute)(state);\n  route.path = path.replace(/\\/$/, '');\n  var params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);\n  if (params) {\n    route.params = _objectSpread(_objectSpread({}, route.params), params);\n  }\n  return state;\n};\nvar parseQueryParams = function parseQueryParams(path, parseConfig) {\n  var query = path.split('?')[1];\n  var params = queryString.parse(query);\n  if (parseConfig) {\n    Object.keys(params).forEach(function (name) {\n      if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n  return Object.keys(params).length ? params : undefined;\n};","map":{"version":3,"names":["_escapeStringRegexp","_interopRequireDefault","require","queryString","_interopRequireWildcard","_arrayStartsWith","_findFocusedRoute","_getPatternParts","_isArrayEqual","_validatePathConfig","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","getStateFromPath","path","options","_options$path","_getConfigResources","getConfigResources","initialRoutes","configs","screens","remaining","replace","endsWith","prefix","normalizedPrefix","startsWith","undefined","routes","split","filter","Boolean","map","segment","name","decodeURIComponent","length","createNestedStateObject","match","find","config","segments","join","routeNames","result","current","_matchAgainstConfigs","matchAgainstConfigs","remainingPath","cachedConfigResources","prepareConfigResources","cached","resources","validatePathConfig","getInitialRoutes","getSortedNormalizedConfigs","checkForDuplicatedConfigs","configWithRegexes","getConfigsWithRegexes","initialRouteName","push","parentScreens","_ref","arguments","concat","apply","_toConsumableArray","keys","key","createNormalizedConfigs","sort","b","isArrayEqual","localeCompare","arrayStartsWith","Math","max","aWildCard","bWildCard","aParam","bParam","aRegex","includes","bRegex","reduce","acc","pattern","intersects","every","it","Error","assign","_defineProperty","c","_objectSpread","regex","RegExp","source","_loop","routeName","routeConfig","screen","params","groups","fromEntries","entries","_ref2","_ref3","_slicedToArray","value","index","Number","param","_ref4","_routeConfig$parse","_ref5","decoded","parsed","parse","_ret","initials","paths","createConfigItem","_config$alias","exact","aliasConfigs","alias","forEach","nestedConfig","pop","parts","_loop2","_screen","getPatternParts","part","_ref6","reg","optional","findParseConfigForRoute","flatConfig","findInitialRoute","sameParents","createStateObject","initialRoute","route","isEmpty","state","shift","nestedState","nestedStateIndex","findFocusedRoute","parseQueryParams","parseConfig","query"],"sources":["C:\\Users\\R User\\Documents\\software_dev\\BranchBuddy\\node_modules\\@react-navigation\\core\\src\\getStateFromPath.tsx"],"sourcesContent":["import type {\n  InitialState,\n  NavigationState,\n  ParamListBase,\n  PartialState,\n} from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\nimport * as queryString from 'query-string';\n\nimport { arrayStartsWith } from './arrayStartsWith';\nimport { findFocusedRoute } from './findFocusedRoute';\nimport { getPatternParts, type PatternPart } from './getPatternParts';\nimport { isArrayEqual } from './isArrayEqual';\nimport type { PathConfig, PathConfigMap } from './types';\nimport { validatePathConfig } from './validatePathConfig';\n\ntype Options<ParamList extends {}> = {\n  path?: string;\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => unknown>;\n\ntype RouteConfig = {\n  screen: string;\n  regex?: RegExp;\n  segments: string[];\n  params: { screen: string; name?: string; index: number }[];\n  routeNames: string[];\n  parse?: ParseConfig;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\ntype ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, unknown> | undefined;\n};\n\ntype ConfigResources = {\n  initialRoutes: InitialRouteConfig[];\n  configs: RouteConfig[];\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport function getStateFromPath<ParamList extends {}>(\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  const { initialRoutes, configs } = getConfigResources(options);\n\n  const screens = options?.screens;\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  const prefix = options?.path?.replace(/^\\//, ''); // Remove extra leading slash\n\n  if (prefix) {\n    // Make sure there is a trailing slash\n    const normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;\n\n    // If the path doesn't start with the prefix, it's not a match\n    if (!remaining.startsWith(normalizedPrefix)) {\n      return undefined;\n    }\n\n    // Remove the prefix from the path\n    remaining = remaining.replace(normalizedPrefix, '');\n  }\n\n  if (screens === undefined) {\n    // When no config is specified, use the path segments as route names\n    const routes = remaining\n      .split('/')\n      .filter(Boolean)\n      .map((segment) => {\n        const name = decodeURIComponent(segment);\n        return { name };\n      });\n\n    if (routes.length) {\n      return createNestedStateObject(path, routes, initialRoutes);\n    }\n\n    return undefined;\n  }\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find((config) => config.segments.join('/') === '');\n\n    if (match) {\n      return createNestedStateObject(\n        path,\n        match.routeNames.map((name) => ({ name })),\n        initialRoutes,\n        configs\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const { routes, remainingPath } = matchAgainstConfigs(remaining, configs);\n\n  if (routes !== undefined) {\n    // This will always be empty if full path matched\n    current = createNestedStateObject(path, routes, initialRoutes, configs);\n    remaining = remainingPath;\n    result = current;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  return result;\n}\n\n/**\n * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.\n */\nconst cachedConfigResources = new WeakMap<Options<{}>, ConfigResources>();\n\nfunction getConfigResources<ParamList extends {}>(\n  options: Options<ParamList> | undefined\n) {\n  if (!options) return prepareConfigResources();\n\n  const cached = cachedConfigResources.get(options);\n\n  if (cached) return cached;\n\n  const resources = prepareConfigResources(options);\n\n  cachedConfigResources.set(options, resources);\n\n  return resources;\n}\n\nfunction prepareConfigResources(options?: Options<{}>) {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const initialRoutes = getInitialRoutes(options);\n  const configs = getSortedNormalizedConfigs(initialRoutes, options?.screens);\n\n  checkForDuplicatedConfigs(configs);\n\n  const configWithRegexes = getConfigsWithRegexes(configs);\n\n  return {\n    initialRoutes,\n    configs,\n    configWithRegexes,\n  };\n}\n\nfunction getInitialRoutes(options?: Options<{}>) {\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  return initialRoutes;\n}\n\nfunction getSortedNormalizedConfigs(\n  initialRoutes: InitialRouteConfig[],\n  screens: Record<string, string | PathConfig<ParamListBase>> = {}\n) {\n  // Create a normalized configs array which will be easier to use\n  return ([] as RouteConfig[])\n    .concat(\n      ...Object.keys(screens).map((key) =>\n        createNormalizedConfigs(key, screens, initialRoutes, [], [], [])\n      )\n    )\n    .sort((a, b) => {\n      // Sort config from most specific to least specific:\n      // - more segments\n      // - static segments\n      // - params with regex\n      // - regular params\n      // - wildcard\n\n      // If 2 patterns are same, move the one with less route names up\n      // This is an error state, so it's only useful for consistent error messages\n      if (isArrayEqual(a.segments, b.segments)) {\n        return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n      }\n\n      // If one of the patterns starts with the other, it's more exhaustive\n      // So move it up\n      if (arrayStartsWith(a.segments, b.segments)) {\n        return -1;\n      }\n\n      if (arrayStartsWith(b.segments, a.segments)) {\n        return 1;\n      }\n\n      for (let i = 0; i < Math.max(a.segments.length, b.segments.length); i++) {\n        // if b is longer, b gets higher priority\n        if (a.segments[i] == null) {\n          return 1;\n        }\n\n        // if a is longer, a gets higher priority\n        if (b.segments[i] == null) {\n          return -1;\n        }\n\n        const aWildCard = a.segments[i] === '*';\n        const bWildCard = b.segments[i] === '*';\n        const aParam = a.segments[i].startsWith(':');\n        const bParam = b.segments[i].startsWith(':');\n        const aRegex = aParam && a.segments[i].includes('(');\n        const bRegex = bParam && b.segments[i].includes('(');\n\n        // if both are wildcard or regex, we compare next component\n        if ((aWildCard && bWildCard) || (aRegex && bRegex)) {\n          continue;\n        }\n\n        // if only a is wildcard, b gets higher priority\n        if (aWildCard && !bWildCard) {\n          return 1;\n        }\n\n        // if only b is wildcard, a gets higher priority\n        if (bWildCard && !aWildCard) {\n          return -1;\n        }\n\n        // If only a has a param, b gets higher priority\n        if (aParam && !bParam) {\n          return 1;\n        }\n\n        // If only b has a param, a gets higher priority\n        if (bParam && !aParam) {\n          return -1;\n        }\n\n        // if only a has regex, a gets higher priority\n        if (aRegex && !bRegex) {\n          return -1;\n        }\n\n        // if only b has regex, b gets higher priority\n        if (bRegex && !aRegex) {\n          return 1;\n        }\n      }\n\n      return a.segments.length - b.segments.length;\n    });\n}\n\nfunction checkForDuplicatedConfigs(configs: RouteConfig[]) {\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    const pattern = config.segments.join('/');\n\n    if (acc[pattern]) {\n      const a = acc[pattern].routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length\n          ? b.every((it, i) => a[i] === it)\n          : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        throw new Error(\n          `Found conflicting screens with the same pattern. The pattern '${\n            pattern\n          }' resolves to both '${a.join(' > ')}' and '${b.join(\n            ' > '\n          )}'. Patterns must be unique and cannot resolve to more than one screen.`\n        );\n      }\n    }\n\n    return Object.assign(acc, {\n      [pattern]: config,\n    });\n  }, {});\n}\n\nfunction getConfigsWithRegexes(configs: RouteConfig[]) {\n  return configs.map((c) => ({\n    ...c,\n    // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n    regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,\n  }));\n}\n\nconst matchAgainstConfigs = (remaining: string, configs: RouteConfig[]) => {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (match) {\n      routes = config.routeNames.map((routeName) => {\n        const routeConfig = configs.find((c) => {\n          // Check matching name AND pattern in case same screen is used at different levels in config\n          return (\n            c.screen === routeName &&\n            arrayStartsWith(config.segments, c.segments)\n          );\n        });\n\n        const params =\n          routeConfig && match.groups\n            ? Object.fromEntries(\n                Object.entries(match.groups)\n                  .map(([key, value]) => {\n                    const index = Number(key.replace('param_', ''));\n                    const param = routeConfig.params.find(\n                      (it) => it.index === index\n                    );\n\n                    if (param?.screen === routeName && param?.name) {\n                      return [param.name, value];\n                    }\n\n                    return null;\n                  })\n                  .filter((it) => it != null)\n                  .map(([key, value]) => {\n                    if (value == null) {\n                      return [key, undefined];\n                    }\n\n                    const decoded = decodeURIComponent(value);\n                    const parsed = routeConfig.parse?.[key]\n                      ? routeConfig.parse[key](decoded)\n                      : decoded;\n\n                    return [key, parsed];\n                  })\n              )\n            : undefined;\n\n        if (params && Object.keys(params).length) {\n          return { name: routeName, params };\n        }\n\n        return { name: routeName };\n      });\n\n      remainingPath = remainingPath.replace(match[0], '');\n\n      break;\n    }\n  }\n\n  return { routes, remainingPath };\n};\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: Record<string, string | PathConfig<ParamListBase>>,\n  initials: InitialRouteConfig[],\n  paths: { screen: string; path: string }[],\n  parentScreens: string[],\n  routeNames: string[]\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  const config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    paths.push({ screen, path: config });\n    configs.push(createConfigItem(screen, [...routeNames], [...paths]));\n  } else if (typeof config === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path == null) {\n        throw new Error(\n          `Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \\`path: ''\\`.`\n        );\n      }\n\n      // We should add alias configs after the main config\n      // So unless they are more specific, main config will be matched first\n      const aliasConfigs = [];\n\n      if (config.alias) {\n        for (const alias of config.alias) {\n          if (typeof alias === 'string') {\n            aliasConfigs.push(\n              createConfigItem(\n                screen,\n                [...routeNames],\n                [...paths, { screen, path: alias }],\n                config.parse\n              )\n            );\n          } else if (typeof alias === 'object') {\n            aliasConfigs.push(\n              createConfigItem(\n                screen,\n                [...routeNames],\n                alias.exact\n                  ? [{ screen, path: alias.path }]\n                  : [...paths, { screen, path: alias.path }],\n                alias.parse\n              )\n            );\n          }\n        }\n      }\n\n      if (config.exact) {\n        // If it's an exact path, we don't need to keep track of the parent screens\n        // So we can clear it\n        paths.length = 0;\n      }\n\n      paths.push({ screen, path: config.path });\n      configs.push(\n        createConfigItem(screen, [...routeNames], [...paths], config.parse)\n      );\n\n      configs.push(...aliasConfigs);\n    }\n\n    if (\n      typeof config !== 'string' &&\n      typeof config.path !== 'string' &&\n      config.alias?.length\n    ) {\n      throw new Error(\n        `Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as Record<string, string | PathConfig<ParamListBase>>,\n          initials,\n          [...paths],\n          [...parentScreens],\n          routeNames\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  paths: { screen: string; path: string }[],\n  parse?: ParseConfig\n): RouteConfig => {\n  const parts: (PatternPart & { screen: string })[] = [];\n\n  // Parse the path string into parts for easier matching\n  for (const { screen, path } of paths) {\n    parts.push(...getPatternParts(path).map((part) => ({ ...part, screen })));\n  }\n\n  const regex = parts.length\n    ? new RegExp(\n        `^(${parts\n          .map((it, i) => {\n            if (it.param) {\n              const reg = it.regex || '[^/]+';\n\n              return `(((?<param_${i}>${reg})\\\\/)${it.optional ? '?' : ''})`;\n            }\n\n            return `${it.segment === '*' ? '.*' : escape(it.segment)}\\\\/`;\n          })\n          .join('')})$`\n      )\n    : undefined;\n\n  const segments = parts.map((it) => it.segment);\n  const params = parts\n    .map((it, i) =>\n      it.param\n        ? {\n            index: i,\n            screen: it.screen,\n            name: it.param,\n          }\n        : null\n    )\n    .filter((it) => it != null);\n\n  return {\n    screen,\n    regex,\n    segments,\n    params,\n    routeNames,\n    parse,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (parentScreens.length === config.parentScreens.length) {\n      let sameParents = true;\n      for (let i = 0; i < parentScreens.length; i++) {\n        if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\n          sameParents = false;\n          break;\n        }\n      }\n      if (sameParents) {\n        return routeName !== config.initialRouteName\n          ? config.initialRouteName\n          : undefined;\n      }\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  route: ParsedRoute,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, route],\n      };\n    } else {\n      return {\n        routes: [route],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n      };\n    } else {\n      return {\n        routes: [{ ...route, state: { routes: [] } }],\n      };\n    }\n  }\n};\n\nconst createNestedStateObject = (\n  path: string,\n  routes: ParsedRoute[],\n  initialRoutes: InitialRouteConfig[],\n  flatConfig?: RouteConfig[]\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(\n    initialRoute,\n    route,\n    routes.length === 0\n  );\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex =\n        nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex]\n          .state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n  route.path = path.replace(/\\/$/, '');\n\n  const params = parseQueryParams(\n    path,\n    flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return state;\n};\n\nconst parseQueryParams = (\n  path: string,\n  parseConfig?: Record<string, (value: string) => unknown>\n) => {\n  const query = path.split('?')[1];\n  const params: Record<string, unknown> = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (\n        Object.hasOwnProperty.call(parseConfig, name) &&\n        typeof params[name] === 'string'\n      ) {\n        params[name] = parseConfig[name](params[name]);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}