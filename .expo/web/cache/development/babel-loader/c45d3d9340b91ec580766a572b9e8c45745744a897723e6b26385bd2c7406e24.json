{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveHrefStringWithSegments = exports.resolveHref = void 0;\nvar resolveHref = function resolveHref(href) {\n  var _href$pathname;\n  if (typeof href === 'string') {\n    return (0, exports.resolveHref)({\n      pathname: href\n    });\n  }\n  var path = (_href$pathname = href.pathname) != null ? _href$pathname : '';\n  if (!(href != null && href.params)) {\n    return path;\n  }\n  var _createQualifiedPathn = createQualifiedPathname(path, _objectSpread({}, href.params)),\n    pathname = _createQualifiedPathn.pathname,\n    params = _createQualifiedPathn.params;\n  var paramsString = createQueryParams(params);\n  return pathname + (paramsString ? `?${paramsString}` : '');\n};\nexports.resolveHref = resolveHref;\nfunction resolveHrefStringWithSegments(href) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$segments = _ref.segments,\n    segments = _ref$segments === void 0 ? [] : _ref$segments,\n    _ref$params = _ref.params,\n    params = _ref$params === void 0 ? {} : _ref$params;\n  var relativeToDirectory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (href.startsWith('.')) {\n    var _segments$map$filter$;\n    var base = (_segments$map$filter$ = segments == null ? void 0 : segments.map(function (segment) {\n      if (!segment.startsWith('[')) return segment;\n      if (segment.startsWith('[...')) {\n        segment = segment.slice(4, -1);\n        var param = params[segment];\n        if (Array.isArray(param)) {\n          return param.join('/');\n        } else {\n          var _param$split$join, _param$split;\n          return (_param$split$join = param == null ? void 0 : (_param$split = param.split(',')) == null ? void 0 : _param$split.join('/')) != null ? _param$split$join : '';\n        }\n      } else {\n        segment = segment.slice(1, -1);\n        return params[segment];\n      }\n    }).filter(Boolean).join('/')) != null ? _segments$map$filter$ : '/';\n    if (relativeToDirectory) {\n      base = `${base}/`;\n    }\n    var url = new URL(href, `http://hostname/${base}`);\n    href = `${url.pathname}${url.search}`;\n  }\n  return href;\n}\nexports.resolveHrefStringWithSegments = resolveHrefStringWithSegments;\nfunction createQualifiedPathname(pathname, params) {\n  for (var _ref2 of Object.entries(params)) {\n    var _ref3 = _slicedToArray(_ref2, 2);\n    var key = _ref3[0];\n    var _ref3$ = _ref3[1];\n    var value = _ref3$ === void 0 ? '' : _ref3$;\n    var dynamicKey = `[${key}]`;\n    var deepDynamicKey = `[...${key}]`;\n    if (pathname.includes(dynamicKey)) {\n      pathname = pathname.replace(dynamicKey, encodeParam(value));\n    } else if (pathname.includes(deepDynamicKey)) {\n      pathname = pathname.replace(deepDynamicKey, encodeParam(value));\n    } else {\n      continue;\n    }\n    delete params[key];\n  }\n  return {\n    pathname: pathname,\n    params: params\n  };\n}\nfunction encodeParam(param) {\n  if (Array.isArray(param)) {\n    return param.map(function (p) {\n      return encodeParam(p);\n    }).join('/');\n  }\n  return encodeURIComponent(param.toString());\n}\nfunction createQueryParams(params) {\n  return Object.entries(params).filter(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n      value = _ref5[1];\n    return value != null;\n  }).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      key = _ref7[0],\n      value = _ref7[1];\n    return `${key}=${encodeURIComponent(value.toString())}`;\n  }).join('&');\n}","map":{"version":3,"names":["resolveHref","href","_href$pathname","exports","pathname","path","params","_createQualifiedPathn","createQualifiedPathname","_objectSpread","paramsString","createQueryParams","resolveHrefStringWithSegments","_ref","arguments","length","undefined","_ref$segments","segments","_ref$params","relativeToDirectory","startsWith","_segments$map$filter$","base","map","segment","slice","param","Array","isArray","join","_param$split$join","_param$split","split","filter","Boolean","url","URL","search","_ref2","Object","entries","_ref3","_slicedToArray","key","_ref3$","value","dynamicKey","deepDynamicKey","includes","replace","encodeParam","p","encodeURIComponent","toString","_ref4","_ref5","_ref6","_ref7"],"sources":["C:\\Users\\R User\\Documents\\software_dev\\BranchBuddy\\node_modules\\expo-router\\src\\link\\href.ts"],"sourcesContent":["import { UrlObject } from '../LocationProvider';\nimport { Href } from '../types';\n\n/** Resolve an href object into a fully qualified, relative href. */\nexport const resolveHref = (href: Href): string => {\n  if (typeof href === 'string') {\n    return resolveHref({ pathname: href });\n  }\n  const path = href.pathname ?? '';\n  if (!href?.params) {\n    return path;\n  }\n  const { pathname, params } = createQualifiedPathname(path, {\n    ...href.params,\n  });\n  const paramsString = createQueryParams(params);\n  return pathname + (paramsString ? `?${paramsString}` : '');\n};\n\nexport function resolveHrefStringWithSegments(\n  href: string,\n  { segments = [], params = {} }: Partial<UrlObject> = {},\n  relativeToDirectory: boolean = false\n) {\n  if (href.startsWith('.')) {\n    // Resolve base path by merging the current segments with the params\n    let base =\n      segments\n        ?.map((segment) => {\n          if (!segment.startsWith('[')) return segment;\n\n          if (segment.startsWith('[...')) {\n            segment = segment.slice(4, -1);\n            const param = params[segment];\n            if (Array.isArray(param)) {\n              return param.join('/');\n            } else {\n              return param?.split(',')?.join('/') ?? '';\n            }\n          } else {\n            segment = segment.slice(1, -1);\n            return params[segment];\n          }\n        })\n        .filter(Boolean)\n        .join('/') ?? '/';\n\n    if (relativeToDirectory) {\n      base = `${base}/`;\n    }\n\n    const url = new URL(href, `http://hostname/${base}`);\n\n    href = `${url.pathname}${url.search}`;\n  }\n\n  return href;\n}\n\nfunction createQualifiedPathname(\n  pathname: string,\n  params: Record<string, any>\n): { pathname: string; params: any } {\n  for (const [key, value = ''] of Object.entries(params)) {\n    const dynamicKey = `[${key}]`;\n    const deepDynamicKey = `[...${key}]`;\n    if (pathname.includes(dynamicKey)) {\n      pathname = pathname.replace(dynamicKey, encodeParam(value));\n    } else if (pathname.includes(deepDynamicKey)) {\n      pathname = pathname.replace(deepDynamicKey, encodeParam(value));\n    } else {\n      continue;\n    }\n\n    delete params[key];\n  }\n  return { pathname, params };\n}\n\nfunction encodeParam(param: any): string {\n  if (Array.isArray(param)) {\n    return param.map((p) => encodeParam(p)).join('/');\n  }\n\n  return encodeURIComponent(param.toString());\n}\n\nfunction createQueryParams(params: Record<string, any>): string {\n  return (\n    Object.entries(params)\n      // Allow nullish params\n      .filter(([, value]) => value != null)\n      .map(([key, value]) => `${key}=${encodeURIComponent(value.toString())}`)\n      .join('&')\n  );\n}\n"],"mappings":";;;;;;;;;;AAIO,IAAMA,WAAW,GAAG,SAAdA,WAAWA,CAAIC,IAAU,EAAY;EAAA,IAAAC,cAAA;EAChD,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAO,IAAAE,OAAA,CAAAH,WAAW,EAAC;MAAEI,QAAQ,EAAEH;IAAI,CAAE,CAAC;;EAExC,IAAMI,IAAI,IAAAH,cAAA,GAAGD,IAAI,CAACG,QAAQ,YAAAF,cAAA,GAAI,EAAE;EAChC,IAAI,EAACD,IAAI,YAAJA,IAAI,CAAEK,MAAM,GAAE;IACjB,OAAOD,IAAI;;EAEb,IAAAE,qBAAA,GAA6BC,uBAAuB,CAACH,IAAI,EAAAI,aAAA,KACpDR,IAAI,CAACK,MAAM,CACf,CAAC;IAFMF,QAAQ,GAAAG,qBAAA,CAARH,QAAQ;IAAEE,MAAM,GAAAC,qBAAA,CAAND,MAAM;EAGxB,IAAMI,YAAY,GAAGC,iBAAiB,CAACL,MAAM,CAAC;EAC9C,OAAOF,QAAQ,IAAIM,YAAY,GAAG,IAAIA,YAAY,EAAE,GAAG,EAAE,CAAC;AAC5D,CAAC;AAbYP,OAAA,CAAAH,WAAW,GAAAA,WAAA;AAexB,SAAgBY,6BAA6BA,CAC3CX,IAAY,EAEwB;EAAA,IAAAY,IAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MADiB,EAAE;IAAAG,aAAA,GAAAJ,IAAA,CAArDK,QAAQ;IAARA,QAAQ,GAAAD,aAAA,cAAG,EAAE,GAAAA,aAAA;IAAAE,WAAA,GAAAN,IAAA,CAAEP,MAAM;IAANA,MAAM,GAAAa,WAAA,cAAG,EAAE,GAAAA,WAAA;EAAA,IAC5BC,mBAAA,GAAAN,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA+B,KAAK;EAEpC,IAAIb,IAAI,CAACoB,UAAU,CAAC,GAAG,CAAC,EAAE;IAAA,IAAAC,qBAAA;IAExB,IAAIC,IAAI,IAAAD,qBAAA,GACNJ,QAAQ,oBAARA,QAAQ,CACJM,GAAG,CAAC,UAACC,OAAO,EAAI;MAChB,IAAI,CAACA,OAAO,CAACJ,UAAU,CAAC,GAAG,CAAC,EAAE,OAAOI,OAAO;MAE5C,IAAIA,OAAO,CAACJ,UAAU,CAAC,MAAM,CAAC,EAAE;QAC9BI,OAAO,GAAGA,OAAO,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC9B,IAAMC,KAAK,GAAGrB,MAAM,CAACmB,OAAO,CAAC;QAC7B,IAAIG,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;UACxB,OAAOA,KAAK,CAACG,IAAI,CAAC,GAAG,CAAC;SACvB,MAAM;UAAA,IAAAC,iBAAA,EAAAC,YAAA;UACL,QAAAD,iBAAA,GAAOJ,KAAK,qBAAAK,YAAA,GAALL,KAAK,CAAEM,KAAK,CAAC,GAAG,CAAC,qBAAjBD,YAAA,CAAmBF,IAAI,CAAC,GAAG,CAAC,YAAAC,iBAAA,GAAI,EAAE;;OAE5C,MAAM;QACLN,OAAO,GAAGA,OAAO,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC9B,OAAOpB,MAAM,CAACmB,OAAO,CAAC;;IAE1B,CAAC,CAAC,CACDS,MAAM,CAACC,OAAO,CAAC,CACfL,IAAI,CAAC,GAAG,CAAC,YAAAR,qBAAA,GAAI,GAAG;IAErB,IAAIF,mBAAmB,EAAE;MACvBG,IAAI,GAAG,GAAGA,IAAI,GAAG;;IAGnB,IAAMa,GAAG,GAAG,IAAIC,GAAG,CAACpC,IAAI,EAAE,mBAAmBsB,IAAI,EAAE,CAAC;IAEpDtB,IAAI,GAAG,GAAGmC,GAAG,CAAChC,QAAQ,GAAGgC,GAAG,CAACE,MAAM,EAAE;;EAGvC,OAAOrC,IAAI;AACb;AAtCAE,OAAA,CAAAS,6BAAA,GAAAA,6BAAA;AAwCA,SAASJ,uBAAuBA,CAC9BJ,QAAgB,EAChBE,MAA2B;EAE3B,SAAAiC,KAAA,IAAgCC,MAAM,CAACC,OAAO,CAACnC,MAAM,CAAC,EAAE;IAAA,IAAAoC,KAAA,GAAAC,cAAA,CAAAJ,KAAA;IAAA,IAA5CK,GAAG,GAAAF,KAAA;IAAA,IAAAG,MAAA,GAAAH,KAAA;IAAA,IAAEI,KAAK,GAAAD,MAAA,cAAG,EAAE,GAAAA,MAAA;IACzB,IAAME,UAAU,GAAG,IAAIH,GAAG,GAAG;IAC7B,IAAMI,cAAc,GAAG,OAAOJ,GAAG,GAAG;IACpC,IAAIxC,QAAQ,CAAC6C,QAAQ,CAACF,UAAU,CAAC,EAAE;MACjC3C,QAAQ,GAAGA,QAAQ,CAAC8C,OAAO,CAACH,UAAU,EAAEI,WAAW,CAACL,KAAK,CAAC,CAAC;KAC5D,MAAM,IAAI1C,QAAQ,CAAC6C,QAAQ,CAACD,cAAc,CAAC,EAAE;MAC5C5C,QAAQ,GAAGA,QAAQ,CAAC8C,OAAO,CAACF,cAAc,EAAEG,WAAW,CAACL,KAAK,CAAC,CAAC;KAChE,MAAM;MACL;;IAGF,OAAOxC,MAAM,CAACsC,GAAG,CAAC;;EAEpB,OAAO;IAAExC,QAAQ,EAARA,QAAQ;IAAEE,MAAM,EAANA;EAAM,CAAE;AAC7B;AAEA,SAAS6C,WAAWA,CAACxB,KAAU;EAC7B,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;IACxB,OAAOA,KAAK,CAACH,GAAG,CAAC,UAAC4B,CAAC;MAAA,OAAKD,WAAW,CAACC,CAAC,CAAC;IAAA,EAAC,CAACtB,IAAI,CAAC,GAAG,CAAC;;EAGnD,OAAOuB,kBAAkB,CAAC1B,KAAK,CAAC2B,QAAQ,EAAE,CAAC;AAC7C;AAEA,SAAS3C,iBAAiBA,CAACL,MAA2B;EACpD,OACEkC,MAAM,CAACC,OAAO,CAACnC,MAAM,CAAC,CAEnB4B,MAAM,CAAC,UAAAqB,KAAA;IAAA,IAAAC,KAAA,GAAAb,cAAA,CAAAY,KAAA;MAAIT,KAAK,GAAAU,KAAA;IAAA,OAAMV,KAAK,IAAI,IAAI;EAAA,EAAC,CACpCtB,GAAG,CAAC,UAAAiC,KAAA;IAAA,IAAAC,KAAA,GAAAf,cAAA,CAAAc,KAAA;MAAEb,GAAG,GAAAc,KAAA;MAAEZ,KAAK,GAAAY,KAAA;IAAA,OAAM,GAAGd,GAAG,IAAIS,kBAAkB,CAACP,KAAK,CAACQ,QAAQ,EAAE,CAAC,EAAE;EAAA,EAAC,CACvExB,IAAI,CAAC,GAAG,CAAC;AAEhB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}