{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseQueryParams = exports.getRouteConfigSorter = exports.appendIsInitial = exports.matchForEmptyPath = exports.stripBaseUrl = exports.spreadParamsAcrossAllStates = exports.handleUrlParams = exports.getParamValue = exports.replacePart = exports.isDynamicPart = exports.configRegExp = exports.assertScreens = exports.createConfig = exports.getUrlWithReactNavigationConcessions = exports.safelyDecodeURIComponent = exports.populateParams = void 0;\nvar escape_string_regexp_1 = __importDefault(require(\"escape-string-regexp\"));\nvar matchers_1 = require(\"../matchers\");\nfunction populateParams(routes, params) {\n  if (!routes || !params || Object.keys(params).length === 0) return;\n  for (var route of routes) {\n    Object.assign(route, {\n      params: params\n    });\n  }\n  return routes;\n}\nexports.populateParams = populateParams;\nfunction safelyDecodeURIComponent(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (_unused) {\n    return str;\n  }\n}\nexports.safelyDecodeURIComponent = safelyDecodeURIComponent;\nfunction getUrlWithReactNavigationConcessions(path) {\n  var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.env.EXPO_BASE_URL;\n  var parsed;\n  try {\n    parsed = new URL(path, 'https://phony.example');\n  } catch (_unused2) {\n    return {\n      path: path,\n      cleanUrl: '',\n      nonstandardPathname: '',\n      url: new URL('https://phony.example')\n    };\n  }\n  var pathname = parsed.pathname;\n  var withoutBaseUrl = stripBaseUrl(pathname, baseUrl);\n  var pathWithoutGroups = (0, matchers_1.stripGroupSegmentsFromPath)(stripBaseUrl(path, baseUrl));\n  return {\n    path: path,\n    nonstandardPathname: withoutBaseUrl.replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n    url: parsed,\n    pathWithoutGroups: pathWithoutGroups\n  };\n}\nexports.getUrlWithReactNavigationConcessions = getUrlWithReactNavigationConcessions;\nfunction createConfig(screen, pattern, routeNames) {\n  var _Object$keys;\n  var config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var parts = [];\n  var isDynamic = false;\n  var isIndex = screen === 'index' || screen.endsWith('/index');\n  for (var part of pattern.split('/')) {\n    if (part) {\n      isDynamic ||= part.startsWith(':') || part.startsWith('*') || part.includes('*not-found');\n      if (!(0, matchers_1.matchGroupName)(part)) {\n        parts.push(part);\n      }\n    }\n  }\n  var hasChildren = config.screens ? !!((_Object$keys = Object.keys(config.screens)) != null && _Object$keys.length) : false;\n  var type = hasChildren ? 'layout' : isDynamic ? 'dynamic' : 'static';\n  if (isIndex) {\n    parts.push('index');\n  }\n  return {\n    type: type,\n    isIndex: isIndex,\n    hasChildren: hasChildren,\n    parts: parts,\n    userReadableName: [].concat(_toConsumableArray(routeNames.slice(0, -1)), [config.path || screen]).join('/'),\n    expandedRouteNames: routeNames.flatMap(function (name) {\n      return name.split('/');\n    })\n  };\n}\nexports.createConfig = createConfig;\nfunction assertScreens(options) {\n  if (!(options != null && options.screens)) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n}\nexports.assertScreens = assertScreens;\nfunction configRegExp(config) {\n  return config.pattern ? new RegExp(`^(${config.pattern.split('/').map(formatRegexPattern).join('')})$`) : undefined;\n}\nexports.configRegExp = configRegExp;\nfunction isDynamicPart(p) {\n  return p.length > 1 && (p.startsWith(':') || p.startsWith('*'));\n}\nexports.isDynamicPart = isDynamicPart;\nfunction replacePart(p) {\n  return p.replace(/^[:*]/, '').replace(/\\?$/, '');\n}\nexports.replacePart = replacePart;\nfunction getParamValue(p, value) {\n  if (p.startsWith('*')) {\n    var values = value.split('/').filter(function (v) {\n      return v !== '';\n    });\n    return values.length === 0 && p.endsWith('?') ? undefined : values;\n  } else {\n    return value;\n  }\n}\nexports.getParamValue = getParamValue;\nfunction formatRegexPattern(it) {\n  it = it.replace(' ', '%20');\n  if (it.startsWith(':')) {\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n  if ((0, matchers_1.matchGroupName)(it) != null) {\n    return `(?:${(0, escape_string_regexp_1.default)(it)}\\\\/)?`;\n  }\n  return (0, escape_string_regexp_1.default)(it) + `\\\\/`;\n}\nfunction handleUrlParams(route, params) {\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params);\n    for (var _ref of Object.entries(params)) {\n      var _route$params, _route$params2;\n      var _ref2 = _slicedToArray(_ref, 2);\n      var name = _ref2[0];\n      var value = _ref2[1];\n      if ((_route$params = route.params) != null && _route$params[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);\n        }\n      }\n      if (!((_route$params2 = route.params) != null && _route$params2[name])) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n}\nexports.handleUrlParams = handleUrlParams;\nfunction spreadParamsAcrossAllStates(state, params) {\n  while (state) {\n    var route = state.routes[0];\n    route.params = Object.assign({}, route.params, params);\n  }\n}\nexports.spreadParamsAcrossAllStates = spreadParamsAcrossAllStates;\nfunction stripBaseUrl(path) {\n  var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.env.EXPO_BASE_URL;\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return path.replace(/^\\/+/g, '/').replace(new RegExp(`^\\\\/?${(0, escape_string_regexp_1.default)(baseUrl)}`, 'g'), '');\n    }\n  }\n  return path;\n}\nexports.stripBaseUrl = stripBaseUrl;\nfunction matchForEmptyPath(configs) {\n  var _ref3, _leafNodes$find;\n  var leafNodes = configs.filter(function (config) {\n    return !config.hasChildren;\n  }).map(function (value) {\n    return _objectSpread(_objectSpread({}, value), {}, {\n      path: (0, matchers_1.stripGroupSegmentsFromPath)(value.path)\n    });\n  });\n  var match = (_ref3 = (_leafNodes$find = leafNodes.find(function (config) {\n    return (config.path === '' && (!config.regex || config.regex.test(''))\n    );\n  })) != null ? _leafNodes$find : leafNodes.find(function (config) {\n    return (config.path.startsWith(':') && config.regex.test('')\n    );\n  })) != null ? _ref3 : leafNodes.find(function (config) {\n    return config.path.startsWith('*') && config.regex.test('/');\n  });\n  return match;\n}\nexports.matchForEmptyPath = matchForEmptyPath;\nfunction appendIsInitial(initialRoutes) {\n  var resolvedInitialPatterns = initialRoutes.map(function (route) {\n    return joinPaths.apply(void 0, _toConsumableArray(route.parentScreens).concat([route.initialRouteName]));\n  });\n  return function (config) {\n    config.isInitial = resolvedInitialPatterns.includes(config.routeNames.join('/'));\n    return config;\n  };\n}\nexports.appendIsInitial = appendIsInitial;\nvar joinPaths = function joinPaths() {\n  var _ref4;\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n  return (_ref4 = []).concat.apply(_ref4, _toConsumableArray(paths.map(function (p) {\n    return p.split('/');\n  }))).filter(Boolean).join('/');\n};\nfunction getRouteConfigSorter() {\n  var previousSegments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return function sortConfigs(a, b) {\n    if (a.pattern === b.pattern) {\n      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n    }\n    if (a.pattern.startsWith(b.pattern) && !b.isIndex) {\n      return -1;\n    }\n    if (b.pattern.startsWith(a.pattern) && !a.isIndex) {\n      return 1;\n    }\n    if (a.type === 'static' && b.type !== 'static') {\n      return -1;\n    } else if (a.type !== 'static' && b.type === 'static') {\n      return 1;\n    }\n    var similarToPreviousA = previousSegments.filter(function (value, index) {\n      return value === a.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n    var similarToPreviousB = previousSegments.filter(function (value, index) {\n      return value === b.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n    if ((similarToPreviousA.length > 0 || similarToPreviousB.length > 0) && similarToPreviousA.length !== similarToPreviousB.length) {\n      return similarToPreviousB.length - similarToPreviousA.length;\n    }\n    for (var i = 0; i < Math.max(a.parts.length, b.parts.length); i++) {\n      if (a.parts[i] == null) {\n        return 1;\n      }\n      if (b.parts[i] == null) {\n        return -1;\n      }\n      var aWildCard = a.parts[i].startsWith('*');\n      var bWildCard = b.parts[i].startsWith('*');\n      if (aWildCard && bWildCard) {\n        var aNotFound = a.parts[i].match(/^[*]not-found$/);\n        var bNotFound = b.parts[i].match(/^[*]not-found$/);\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n        continue;\n      }\n      if (aWildCard) {\n        return 1;\n      }\n      if (bWildCard) {\n        return -1;\n      }\n      var aSlug = a.parts[i].startsWith(':');\n      var bSlug = b.parts[i].startsWith(':');\n      if (aSlug && bSlug) {\n        var _aNotFound = a.parts[i].match(/^[*]not-found$/);\n        var _bNotFound = b.parts[i].match(/^[*]not-found$/);\n        if (_aNotFound && _bNotFound) {\n          continue;\n        } else if (_aNotFound) {\n          return 1;\n        } else if (_bNotFound) {\n          return -1;\n        }\n        continue;\n      }\n      if (aSlug) {\n        return 1;\n      }\n      if (bSlug) {\n        return -1;\n      }\n    }\n    if (a.isInitial && !b.isInitial) {\n      return -1;\n    } else if (!a.isInitial && b.isInitial) {\n      return 1;\n    }\n    return b.parts.length - a.parts.length;\n  };\n}\nexports.getRouteConfigSorter = getRouteConfigSorter;\nfunction parseQueryParams(path, route, parseConfig, hash) {\n  var searchParams = new URL(path, 'https://phony.example').searchParams;\n  var params = Object.create(null);\n  if (hash) {\n    params['#'] = hash.slice(1);\n  }\n  var _loop = function _loop(name) {\n    var _route$params3;\n    if ((_route$params3 = route.params) != null && _route$params3[name]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);\n      }\n    } else {\n      var values = parseConfig != null && parseConfig.hasOwnProperty(name) ? searchParams.getAll(name).map(function (value) {\n        return parseConfig[name](value);\n      }) : searchParams.getAll(name);\n      params[name] = values.length === 1 ? values[0] : values;\n    }\n  };\n  for (var name of searchParams.keys()) {\n    _loop(name);\n  }\n  return Object.keys(params).length ? params : undefined;\n}\nexports.parseQueryParams = parseQueryParams;","map":{"version":3,"names":["escape_string_regexp_1","__importDefault","require","matchers_1","populateParams","routes","params","Object","keys","length","route","assign","exports","safelyDecodeURIComponent","str","decodeURIComponent","_unused","getUrlWithReactNavigationConcessions","path","baseUrl","arguments","undefined","process","env","EXPO_BASE_URL","parsed","URL","_unused2","cleanUrl","nonstandardPathname","url","pathname","withoutBaseUrl","stripBaseUrl","pathWithoutGroups","stripGroupSegmentsFromPath","replace","createConfig","screen","pattern","routeNames","_Object$keys","config","parts","isDynamic","isIndex","endsWith","part","split","startsWith","includes","matchGroupName","push","hasChildren","screens","type","userReadableName","concat","_toConsumableArray","slice","join","expandedRouteNames","flatMap","name","assertScreens","options","Error","configRegExp","RegExp","map","formatRegexPattern","isDynamicPart","p","replacePart","getParamValue","value","values","filter","v","it","default","handleUrlParams","create","_ref","entries","_route$params","_route$params2","_ref2","_slicedToArray","NODE_ENV","console","warn","spreadParamsAcrossAllStates","state","matchForEmptyPath","configs","_ref3","_leafNodes$find","leafNodes","_objectSpread","match","find","regex","test","appendIsInitial","initialRoutes","resolvedInitialPatterns","joinPaths","apply","parentScreens","initialRouteName","isInitial","_ref4","_len","paths","Array","_key","Boolean","getRouteConfigSorter","previousSegments","sortConfigs","a","b","localeCompare","similarToPreviousA","index","similarToPreviousB","i","Math","max","aWildCard","bWildCard","aNotFound","bNotFound","aSlug","bSlug","parseQueryParams","parseConfig","hash","searchParams","_loop","_route$params3","hasOwnProperty","getAll"],"sources":["C:\\Users\\R User\\Documents\\software_dev\\BranchBuddy\\node_modules\\expo-router\\src\\fork\\getStateFromPath-forks.ts"],"sourcesContent":["import { InitialState } from '@react-navigation/native';\nimport escape from 'escape-string-regexp';\nimport * as queryString from 'query-string';\n\nimport type { InitialRouteConfig, Options, ParsedRoute, RouteConfig } from './getStateFromPath';\nimport { matchGroupName, stripGroupSegmentsFromPath } from '../matchers';\n\nexport type ExpoOptions = {\n  previousSegments?: string[];\n};\n\nexport type ExpoRouteConfig = {\n  type: 'static' | 'dynamic' | 'layout';\n  userReadableName: string;\n  isIndex: boolean;\n  isInitial?: boolean;\n  hasChildren: boolean;\n  expandedRouteNames: string[];\n  parts: string[];\n};\n\n/**\n * In Expo Router, the params are available at all levels of the routing config\n * @param routes\n * @returns\n */\nexport function populateParams(routes?: ParsedRoute[], params?: Record<string, any>) {\n  if (!routes || !params || Object.keys(params).length === 0) return;\n\n  for (const route of routes) {\n    Object.assign(route, { params });\n  }\n\n  return routes;\n}\n\nexport function safelyDecodeURIComponent(str: string) {\n  try {\n    return decodeURIComponent(str);\n  } catch {\n    return str;\n  }\n}\n\nexport function getUrlWithReactNavigationConcessions(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  let parsed: URL;\n  try {\n    parsed = new URL(path, 'https://phony.example');\n  } catch {\n    // Do nothing with invalid URLs.\n    return {\n      path,\n      cleanUrl: '',\n      nonstandardPathname: '',\n      url: new URL('https://phony.example'),\n    };\n  }\n\n  const pathname = parsed.pathname;\n  const withoutBaseUrl = stripBaseUrl(pathname, baseUrl);\n  const pathWithoutGroups = stripGroupSegmentsFromPath(stripBaseUrl(path, baseUrl));\n\n  // Make sure there is a trailing slash\n  return {\n    // The slashes are at the end, not the beginning\n    path,\n    nonstandardPathname: withoutBaseUrl.replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n    url: parsed,\n    pathWithoutGroups,\n  };\n}\n\nexport function createConfig(\n  screen: string,\n  pattern: string,\n  routeNames: string[],\n  config: Record<string, any> = {}\n): Omit<ExpoRouteConfig, 'isInitial'> {\n  const parts: string[] = [];\n  let isDynamic = false;\n  const isIndex = screen === 'index' || screen.endsWith('/index');\n\n  for (const part of pattern.split('/')) {\n    if (part) {\n      // If any part is dynamic, then the route is dynamic\n      isDynamic ||= part.startsWith(':') || part.startsWith('*') || part.includes('*not-found');\n\n      if (!matchGroupName(part)) {\n        parts.push(part);\n      }\n    }\n  }\n\n  const hasChildren = config.screens ? !!Object.keys(config.screens)?.length : false;\n  const type = hasChildren ? 'layout' : isDynamic ? 'dynamic' : 'static';\n\n  if (isIndex) {\n    parts.push('index');\n  }\n\n  return {\n    type,\n    isIndex,\n    hasChildren,\n    parts,\n    userReadableName: [...routeNames.slice(0, -1), config.path || screen].join('/'),\n    expandedRouteNames: routeNames.flatMap((name) => {\n      return name.split('/');\n    }),\n  };\n}\n\nexport function assertScreens(options?: Options<object>): asserts options is Options<object> {\n  if (!options?.screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n}\n\nexport function configRegExp(config: RouteConfig) {\n  return config.pattern\n    ? new RegExp(`^(${config.pattern.split('/').map(formatRegexPattern).join('')})$`)\n    : undefined;\n}\n\nexport function isDynamicPart(p: string) {\n  return p.length > 1 && (p.startsWith(':') || p.startsWith('*'));\n}\n\nexport function replacePart(p: string) {\n  return p.replace(/^[:*]/, '').replace(/\\?$/, '');\n}\n\nexport function getParamValue(p: string, value: string) {\n  if (p.startsWith('*')) {\n    const values = value.split('/').filter((v) => v !== '');\n    return values.length === 0 && p.endsWith('?') ? undefined : values;\n  } else {\n    return value;\n  }\n}\n\nfunction formatRegexPattern(it: string): string {\n  // Allow spaces in file path names.\n  it = it.replace(' ', '%20');\n\n  if (it.startsWith(':')) {\n    // TODO: Remove unused match group\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n\n  // Strip groups from the matcher\n  if (matchGroupName(it) != null) {\n    // Groups are optional segments\n    // this enables us to match `/bar` and `/(foo)/bar` for the same route\n    // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group\n    return `(?:${escape(it)}\\\\/)?`;\n  }\n\n  return escape(it) + `\\\\/`;\n}\n\nexport function handleUrlParams(route: ParsedRoute, params?: queryString.ParsedQuery) {\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params) as Record<string, any>;\n    for (const [name, value] of Object.entries(params)) {\n      if (route.params?.[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n          );\n        }\n      }\n\n      if (!route.params?.[name]) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n}\n\nexport function spreadParamsAcrossAllStates(state: InitialState, params?: Record<string, any>) {\n  while (state) {\n    const route = state.routes[0];\n    (route as any).params = Object.assign({}, route.params, params);\n  }\n}\n\nexport function stripBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return path.replace(/^\\/+/g, '/').replace(new RegExp(`^\\\\/?${escape(baseUrl)}`, 'g'), '');\n    }\n  }\n  return path;\n}\n\nexport function matchForEmptyPath(configs: RouteConfig[]) {\n  // We need to add special handling of empty path so navigation to empty path also works\n  // When handling empty path, we should only look at the root level config\n\n  // NOTE(EvanBacon): We only care about matching leaf nodes.\n  const leafNodes = configs\n    .filter((config) => !config.hasChildren)\n    .map((value) => {\n      return {\n        ...value,\n        // Collapse all levels of group segments before testing.\n        // This enables `app/(one)/(two)/index.js` to be matched.\n        path: stripGroupSegmentsFromPath(value.path),\n      };\n    });\n\n  const match =\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.\n        config.path === '' && (!config.regex || config.regex.test(''))\n    ) ??\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.\n        config.path.startsWith(':') && config.regex!.test('')\n    ) ??\n    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.\n    // This should be done last to enable dynamic routes having a higher priority.\n    leafNodes.find((config) => config.path.startsWith('*') && config.regex!.test('/'));\n\n  return match;\n}\n\nexport function appendIsInitial(initialRoutes: InitialRouteConfig[]) {\n  const resolvedInitialPatterns = initialRoutes.map((route) =>\n    joinPaths(...route.parentScreens, route.initialRouteName)\n  );\n\n  return function (config: RouteConfig) {\n    // TODO(EvanBacon): Probably a safer way to do this\n    // Mark initial routes to give them potential priority over other routes that match.\n    config.isInitial = resolvedInitialPatterns.includes(config.routeNames.join('/'));\n    return config;\n  };\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nexport function getRouteConfigSorter(previousSegments: string[] = []) {\n  return function sortConfigs(a: RouteConfig, b: RouteConfig) {\n    // Sort config so that:\n    // - the most exhaustive ones are always at the beginning\n    // - patterns with wildcard are always at the end\n\n    // If 2 patterns are same, move the one with less route names up\n    // This is an error state, so it's only useful for consistent error messages\n    if (a.pattern === b.pattern) {\n      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n    }\n\n    /*\n     * If one of the patterns starts with the other, it is earlier in the config sorting.\n     * However, configs are a mix of route configs and layout configs\n     * e.g There will be a config for `/(group)`, but maybe there isn't a `/(group)/index.tsx`\n     *\n     * This is because you can navigate to a directory and its navigator will determine the route\n     * These routes should be later in the config sorting, as their patterns are very open\n     * and will prevent routes from being matched\n     *\n     * Therefore before we compare segment parts, we force these layout configs later in the sorting\n     *\n     * NOTE(marklawlor): Is this a feature we want? I'm unsure if this is a gimmick or a feature.\n     */\n    if (a.pattern.startsWith(b.pattern) && !b.isIndex) {\n      return -1;\n    }\n\n    if (b.pattern.startsWith(a.pattern) && !a.isIndex) {\n      return 1;\n    }\n\n    /*\n     * Static routes should always be higher than dynamic and layout routes.\n     */\n    if (a.type === 'static' && b.type !== 'static') {\n      return -1;\n    } else if (a.type !== 'static' && b.type === 'static') {\n      return 1;\n    }\n\n    /*\n     * If both are static/dynamic or a layout file, then we check group similarity\n     */\n    const similarToPreviousA = previousSegments.filter((value, index) => {\n      return value === a.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n\n    const similarToPreviousB = previousSegments.filter((value, index) => {\n      return value === b.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n\n    if (\n      (similarToPreviousA.length > 0 || similarToPreviousB.length > 0) &&\n      similarToPreviousA.length !== similarToPreviousB.length\n    ) {\n      // One matches more than the other, so pick the one that matches more\n      return similarToPreviousB.length - similarToPreviousA.length;\n    }\n\n    /*\n     * If there is not difference in similarity, then each non-group segment is compared against each other\n     */\n    for (let i = 0; i < Math.max(a.parts.length, b.parts.length); i++) {\n      // if b is longer, b get higher priority\n      if (a.parts[i] == null) {\n        return 1;\n      }\n      // if a is longer, a get higher priority\n      if (b.parts[i] == null) {\n        return -1;\n      }\n\n      const aWildCard = a.parts[i].startsWith('*');\n      const bWildCard = b.parts[i].startsWith('*');\n      // if both are wildcard we compare next component\n      if (aWildCard && bWildCard) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n        continue;\n      }\n      // if only a is wild card, b get higher priority\n      if (aWildCard) {\n        return 1;\n      }\n      // if only b is wild card, a get higher priority\n      if (bWildCard) {\n        return -1;\n      }\n\n      const aSlug = a.parts[i].startsWith(':');\n      const bSlug = b.parts[i].startsWith(':');\n      // if both are wildcard we compare next component\n      if (aSlug && bSlug) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n\n        continue;\n      }\n      // if only a is wild card, b get higher priority\n      if (aSlug) {\n        return 1;\n      }\n      // if only b is wild card, a get higher priority\n      if (bSlug) {\n        return -1;\n      }\n    }\n\n    /*\n     * Both configs are identical in specificity and segments count/type\n     * Try and sort by initial instead.\n     *\n     * TODO: We don't differentiate between the default initialRoute and group specific default routes\n     *\n     * const unstable_settings = {\n     *   \"group\": {\n     *     initialRouteName: \"article\"\n     *  }\n     * }\n     *\n     * \"article\" will be ranked higher because its an initialRoute for a group - even if not your not currently in\n     * that group. The current work around is to ways provide initialRouteName for all groups\n     */\n    if (a.isInitial && !b.isInitial) {\n      return -1;\n    } else if (!a.isInitial && b.isInitial) {\n      return 1;\n    }\n\n    return b.parts.length - a.parts.length;\n  };\n}\n\nexport function parseQueryParams(\n  path: string,\n  route: ParsedRoute,\n  parseConfig?: Record<string, (value: string) => any>,\n  hash?: string\n) {\n  const searchParams = new URL(path, 'https://phony.example').searchParams;\n  const params: Record<string, string | string[]> = Object.create(null);\n\n  if (hash) {\n    params['#'] = hash.slice(1);\n  }\n\n  for (const name of searchParams.keys()) {\n    if (route.params?.[name]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n        );\n      }\n    } else {\n      const values = parseConfig?.hasOwnProperty(name)\n        ? searchParams.getAll(name).map((value) => parseConfig[name](value))\n        : searchParams.getAll(name);\n\n      // searchParams.getAll returns an array.\n      // if we only have a single value, and its not an array param, we need to extract the value\n      params[name] = values.length === 1 ? values[0] : values;\n    }\n  }\n\n  return Object.keys(params).length ? params : undefined;\n}\n\n/*** ????????? */\n\n// export function mutateRouteParams(\n//   route: ParsedRoute,\n//   params: object,\n//   { allowUrlParamNormalization = false } = {}\n// ) {\n//   route.params = Object.assign(Object.create(null), route.params) as Record<string, any>;\n//   for (const [name, value] of Object.entries(params)) {\n//     if (route.params?.[name]) {\n//       if (allowUrlParamNormalization) {\n//         route.params[name] = value;\n//       } else {\n//         if (process.env.NODE_ENV !== 'production') {\n//           console.warn(\n//             `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n//           );\n//         }\n//       }\n//     } else {\n//       route.params[name] = value;\n//     }\n//   }\n\n//   if (Object.keys(route.params).length === 0) {\n//     delete route.params;\n//   }\n// }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}