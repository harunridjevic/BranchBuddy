{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\nvar _objectWithoutProperties = require(\"@babel/runtime/helpers/objectWithoutProperties\");\nvar _excluded = [\"linking\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createStaticNavigation = createStaticNavigation;\nvar _core = require(\"@react-navigation/core\");\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _NavigationContainer = require(\"./NavigationContainer.js\");\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n    t = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {\n    return e ? t : r;\n  })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n  var t = _getRequireWildcardCache(r);\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n      __proto__: null\n    },\n    a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n  return n.default = e, t && t.set(e, n), n;\n}\nfunction createStaticNavigation(tree) {\n  var Component = (0, _core.createComponentForStaticNavigation)(tree, 'RootNavigator');\n  function Navigation(_ref, ref) {\n    var _linking$config4, _linking$config5;\n    var linking = _ref.linking,\n      rest = _objectWithoutProperties(_ref, _excluded);\n    var linkingConfig = React.useMemo(function () {\n      var _linking$config, _linking$config2, _linking$config3;\n      var screens = (0, _core.createPathConfigForStaticNavigation)(tree, {\n        initialRouteName: linking == null ? void 0 : (_linking$config = linking.config) == null ? void 0 : _linking$config.initialRouteName\n      }, (linking == null ? void 0 : linking.enabled) === 'auto');\n      if (!screens) return;\n      return {\n        path: linking == null ? void 0 : (_linking$config2 = linking.config) == null ? void 0 : _linking$config2.path,\n        initialRouteName: linking == null ? void 0 : (_linking$config3 = linking.config) == null ? void 0 : _linking$config3.initialRouteName,\n        screens: screens\n      };\n    }, [linking == null ? void 0 : linking.enabled, linking == null ? void 0 : (_linking$config4 = linking.config) == null ? void 0 : _linking$config4.path, linking == null ? void 0 : (_linking$config5 = linking.config) == null ? void 0 : _linking$config5.initialRouteName]);\n    var memoizedLinking = React.useMemo(function () {\n      if (!linking) {\n        return undefined;\n      }\n      var enabled = typeof linking.enabled === 'boolean' ? linking.enabled : (linkingConfig == null ? void 0 : linkingConfig.screens) != null;\n      return _objectSpread(_objectSpread({}, linking), {}, {\n        enabled: enabled,\n        config: linkingConfig\n      });\n    }, [linking, linkingConfig]);\n    if ((linking == null ? void 0 : linking.enabled) === true && (linkingConfig == null ? void 0 : linkingConfig.screens) == null) {\n      throw new Error('Linking is enabled but no linking configuration was found for the screens.\\n\\n' + 'To solve this:\\n' + \"- Specify a 'linking' property for the screens you want to link to.\\n\" + \"- Or set 'linking.enabled' to 'auto' to generate paths automatically.\\n\\n\" + 'See usage guide: https://reactnavigation.org/docs/static-configuration#linking');\n    }\n    return (0, _jsxRuntime.jsx)(_NavigationContainer.NavigationContainer, _objectSpread(_objectSpread({}, rest), {}, {\n      ref: ref,\n      linking: memoizedLinking,\n      children: (0, _jsxRuntime.jsx)(Component, {})\n    }));\n  }\n  return React.forwardRef(Navigation);\n}","map":{"version":3,"names":["_core","require","React","_interopRequireWildcard","_NavigationContainer","_jsxRuntime","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","createStaticNavigation","tree","Component","createComponentForStaticNavigation","Navigation","_ref","ref","_linking$config4","_linking$config5","linking","rest","_objectWithoutProperties","_excluded","linkingConfig","useMemo","_linking$config","_linking$config2","_linking$config3","screens","createPathConfigForStaticNavigation","initialRouteName","config","enabled","path","memoizedLinking","undefined","_objectSpread","Error","jsx","NavigationContainer","children","forwardRef"],"sources":["C:\\Users\\R User\\Documents\\software_dev\\BranchBuddy\\node_modules\\@react-navigation\\native\\src\\createStaticNavigation.tsx"],"sourcesContent":["import {\n  createComponentForStaticNavigation,\n  createPathConfigForStaticNavigation,\n  type NavigationContainerRef,\n  type ParamListBase,\n  type StaticNavigation,\n} from '@react-navigation/core';\nimport * as React from 'react';\n\nimport { NavigationContainer } from './NavigationContainer';\nimport type { LinkingOptions } from './types';\n\ntype Props = Omit<\n  React.ComponentProps<typeof NavigationContainer>,\n  'linking' | 'children'\n> & {\n  /**\n   * Options for deep linking.\n   */\n  linking?: Omit<LinkingOptions<ParamListBase>, 'config' | 'enabled'> & {\n    /**\n     * Whether deep link handling should be enabled.\n     * Defaults to `true` if any `linking` options are specified, `false` otherwise.\n     *\n     * When 'auto' is specified, all leaf screens will get a autogenerated path.\n     * The generated path will be a kebab-case version of the screen name.\n     * This can be overridden for specific screens by specifying `linking` for the screen.\n     */\n    enabled?: 'auto' | true | false;\n    /**\n     * Additional configuration\n     */\n    config?: Omit<\n      NonNullable<LinkingOptions<ParamListBase>['config']>,\n      'screens'\n    >;\n  };\n};\n\n/**\n * Create a navigation component from a static navigation config.\n * The returned component is a wrapper around `NavigationContainer`.\n *\n * @param tree Static navigation config.\n * @returns Navigation component to use in your app.\n */\nexport function createStaticNavigation(tree: StaticNavigation<any, any, any>) {\n  const Component = createComponentForStaticNavigation(tree, 'RootNavigator');\n\n  function Navigation(\n    { linking, ...rest }: Props,\n    ref: React.Ref<NavigationContainerRef<ParamListBase>>\n  ) {\n    const linkingConfig = React.useMemo(() => {\n      const screens = createPathConfigForStaticNavigation(\n        tree,\n        { initialRouteName: linking?.config?.initialRouteName },\n        linking?.enabled === 'auto'\n      );\n\n      if (!screens) return;\n\n      return {\n        path: linking?.config?.path,\n        initialRouteName: linking?.config?.initialRouteName,\n        screens,\n      };\n    }, [\n      linking?.enabled,\n      linking?.config?.path,\n      linking?.config?.initialRouteName,\n    ]);\n\n    const memoizedLinking = React.useMemo(() => {\n      if (!linking) {\n        return undefined;\n      }\n\n      const enabled =\n        typeof linking.enabled === 'boolean'\n          ? linking.enabled\n          : linkingConfig?.screens != null;\n\n      return {\n        ...linking,\n        enabled,\n        config: linkingConfig,\n      };\n    }, [linking, linkingConfig]);\n\n    if (linking?.enabled === true && linkingConfig?.screens == null) {\n      throw new Error(\n        'Linking is enabled but no linking configuration was found for the screens.\\n\\n' +\n          'To solve this:\\n' +\n          \"- Specify a 'linking' property for the screens you want to link to.\\n\" +\n          \"- Or set 'linking.enabled' to 'auto' to generate paths automatically.\\n\\n\" +\n          'See usage guide: https://reactnavigation.org/docs/static-configuration#linking'\n      );\n    }\n\n    return (\n      <NavigationContainer {...rest} ref={ref} linking={memoizedLinking}>\n        <Component />\n      </NavigationContainer>\n    );\n  }\n\n  return React.forwardRef(Navigation);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}